https://docs.xlwings.org/en/stable/addin.html#xlwings-addin
xlwings quickstart myproject --standalone
This will add the content of the add-in as a single VBA module.
---------------------------------------------------
Path to the AppleScript file:
/Users/agou/Library/Application Scripts/com.microsoft.Excel/xlwings-0.25.3.applescript

VbaHandler("TestString") # Allows to run the script from Script Editor for testing

on VbaHandler(ParameterString)
	set {PYTHONPATH, PythonInterpreter, PythonCommand, WorkbookName, ApplicationFullName, LOG_FILE} to SplitString(ParameterString, "|")
	set ShellCommand to PythonInterpreter & " -B -u -W ignore -c \"import xlwings.utils;xlwings.utils.prepare_sys_path('" & PYTHONPATH & "');" & Â¬
		PythonCommand & " \" \"--wb=" & WorkbookName & "\" \"--from_xl=1\" \"--app=" & ApplicationFullName & "\" > /dev/null 2>\"" & LOG_FILE & "\" & "
	try
		do shell script "source ~/.bash_profile"
		return do shell script "source ~/.bash_profile;" & ShellCommand
	on error errMsg number errNumber
		try
			# Try again without sourcing .bash_profile
			return do shell script ShellCommand
		on error errMsg number errNumber
			return 1
		end try
	end try
end VbaHandler

on SplitString(TheBigString, fieldSeparator)
	# From Ron de Bruin's "Mail from Excel 2016 with Mac Mail example": www.rondebruin.nl
	tell AppleScript
		set oldTID to text item delimiters
		set text item delimiters to fieldSeparator
		set theItems to text items of TheBigString
		set text item delimiters to oldTID
	end tell
	return theItems
end SplitString
---------------------------------------------------

VBAProject(myproject.xlsm) -> Modules -> Module1

Sub SampleCall()    mymodule = Left(ThisWorkbook.name, (InStrRev(ThisWorkbook.name, ".", -1, vbTextCompare) - 1))    RunPython "import " & mymodule & ";" & mymodule & ".main()"End Sub---------------------------------------------------

VBAProject(myproject.xlsm) -> Modules -> xlwings

#Const App = "Microsoft Excel" 'Adjust when using outside of Excel'Version: 0.25.3'Attribute VB_Name = "Main"#If VBA7 Then    #If Mac Then        Private Declare PtrSafe Function system Lib "libc.dylib" (ByVal Command As String) As Long    #End If    #If Win64 Then        Const XLPyDLLName As String = "xlwings64-0.25.3.dll"        Declare PtrSafe Function XLPyDLLActivateAuto Lib "xlwings64-0.25.3.dll" (ByRef result As Variant, Optional ByVal Config As String = "", Optional ByVal mode As Long = 1) As Long        Declare PtrSafe Function XLPyDLLNDims Lib "xlwings64-0.25.3.dll" (ByRef src As Variant, ByRef dims As Long, ByRef transpose As Boolean, ByRef dest As Variant) As Long        Declare PtrSafe Function XLPyDLLVersion Lib "xlwings64-0.25.3.dll" (tag As String, VERSION As Double, arch As String) As Long    #Else        Private Const XLPyDLLName As String = "xlwings32-0.25.3.dll"        Declare PtrSafe Function XLPyDLLActivateAuto Lib "xlwings32-0.25.3.dll" (ByRef result As Variant, Optional ByVal Config As String = "", Optional ByVal mode As Long = 1) As Long        Private Declare PtrSafe Function XLPyDLLNDims Lib "xlwings32-0.25.3.dll" (ByRef src As Variant, ByRef dims As Long, ByRef transpose As Boolean, ByRef dest As Variant) As Long        Private Declare PtrSafe Function XLPyDLLVersion Lib "xlwings32-0.25.3.dll" (tag As String, VERSION As Double, arch As String) As Long    #End If    Private Declare PtrSafe Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long#Else    #If Mac Then        Private Declare Function system Lib "libc.dylib" (ByVal Command As String) As Long    #End If    Private Const XLPyDLLName As String = "xlwings32-0.25.3.dll"    Private Declare Function XLPyDLLActivateAuto Lib "xlwings32-0.25.3.dll" (ByRef result As Variant, Optional ByVal Config As String = "", Optional ByVal mode As Long = 1) As Long    Private Declare Function XLPyDLLNDims Lib "xlwings32-0.25.3.dll" (ByRef src As Variant, ByRef dims As Long, ByRef transpose As Boolean, ByRef dest As Variant) As Long    Private Declare Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long    Declare Function XLPyDLLVersion Lib "xlwings32-0.25.3.dll" (tag As String, VERSION As Double, arch As String) As Long#End IfPublic Const XLWINGS_VERSION As String = "0.25.3"Public Const PROJECT_NAME As String = "xlwings"Public Function RunPython(PythonCommand As String)    ' Public API: Runs the Python command, e.g.: to run the function foo() in module bar, call the function like this:    ' RunPython "import bar; bar.foo()"        Dim i As Integer    Dim SourcePythonCommand As String, interpreter As String, PYTHONPATH As String, licenseKey, ActiveFullName As String, ThisFullName As String    Dim OPTIMIZED_CONNECTION As Boolean, uses_embedded_code As Boolean    Dim wb As Workbook    Dim sht As Worksheet        SourcePythonCommand = PythonCommand        #If Mac Then        interpreter = GetConfig("INTERPRETER_MAC", "")    #Else        interpreter = GetConfig("INTERPRETER_WIN", "")    #End If    If interpreter = "" Then        ' Legacy        interpreter = GetConfig("INTERPRETER", "python")    End If        ' The first 5 args are not technically part of the PYTHONPATH, but it's just easier to add it here (used by xlwings.utils.prepare_sys_path)    #If Mac Then        If InStr(ThisWorkbook.FullName, "://") = 0 Then            ActiveFullName = ToPosixPath(ThisWorkbook.FullName)            ThisFullName = ToPosixPath(ThisWorkbook.FullName)        Else            ActiveFullName = ThisWorkbook.FullName            ThisFullName = ThisWorkbook.FullName        End If    #Else        ActiveFullName = ThisWorkbook.FullName        ThisFullName = ThisWorkbook.FullName    #End If        #If Mac Then        PYTHONPATH = ActiveFullName & ";" & ThisFullName & ";" & GetConfig("ONEDRIVE_CONSUMER_MAC") & ";" & GetConfig("ONEDRIVE_COMMERCIAL_MAC") & ";" & GetConfig("SHAREPOINT_MAC") & ";" & GetConfig("PYTHONPATH")    #Else        PYTHONPATH = ActiveFullName & ";" & ThisFullName & ";" & GetConfig("ONEDRIVE_CONSUMER_WIN") & ";" & GetConfig("ONEDRIVE_COMMERCIAL_WIN") & ";" & GetConfig("SHAREPOINT_WIN") & ";" & GetConfig("PYTHONPATH")    #End If    OPTIMIZED_CONNECTION = GetConfig("USE UDF SERVER", False)    ' Handle embedded Python code    uses_embedded_code = False    For i = 1 To 2        If i = 1 Then            Set wb = ThisWorkbook        Else            Set wb = ThisWorkbook        End If        For Each sht In wb.Worksheets            If Right$(sht.name, 3) = ".py" Then                uses_embedded_code = True                Exit For            End If        Next    Next i    If uses_embedded_code = True Then        licenseKey = GetConfig("LICENSE_KEY")        If licenseKey = "" Then            MsgBox "Embedded code requires a valid LICENSE_KEY."            Exit Function        Else            PythonCommand = "import xlwings.pro;xlwings.pro.runpython_embedded_code('" & SourcePythonCommand & "')"        End If    End If    ' Handle module execute permission (for embedded code that happens in Python)    If LCase(GetConfig("PERMISSION_CHECK_ENABLED", , source:="user")) = "true" And uses_embedded_code = False Then        PythonCommand = "import xlwings.pro;xlwings.pro.verify_execute_permission('" & SourcePythonCommand & "');" & PythonCommand    End If    ' Call Python platform-dependent    #If Mac Then        Application.StatusBar = "Running..."  ' Non-blocking way of giving feedback that something is happening        ExecuteMac PythonCommand, interpreter, PYTHONPATH    #Else        If OPTIMIZED_CONNECTION = True Then            Py.SetAttr Py.Module("xlwings._xlwindows"), "BOOK_CALLER", ThisWorkbook                        On Error GoTo err_handling                        Py.Exec "" & PythonCommand & ""            GoTo end_err_handlingerr_handling:            ShowError "", err.Description            RunPython = -1            On Error GoTo 0end_err_handling:        Else            RunPython = ExecuteWindows(False, PythonCommand, interpreter, PYTHONPATH)        End If    #End IfEnd FunctionSub ExecuteMac(PythonCommand As String, PYTHON_MAC As String, Optional PYTHONPATH As String)    #If Mac Then    Dim PythonInterpreter As String, RunCommand As String, Log As String    Dim ParameterString As String, ExitCode As String, CondaCmd As String, CondaPath As String, CondaEnv As String, LOG_FILE As String    ' Transform paths    PYTHONPATH = Replace(PYTHONPATH, "'", "\'") ' Escaping quotes    If PYTHON_MAC <> "" Then        If PYTHON_MAC <> "python" And PYTHON_MAC <> "pythonw" Then            PythonInterpreter = ToPosixPath(PYTHON_MAC)        Else            PythonInterpreter = PYTHON_MAC        End If    Else        PythonInterpreter = "python"    End If    ' Sandbox location that requires no file access confirmation    ' TODO: Use same logic with GUID like for Windows. Only here the GUID will need to be passed back to CleanUp()    LOG_FILE = Environ("HOME") + "/xlwings.log" '/Users/<User>/Library/Containers/com.microsoft.Excel/Data/xlwings.log    ' Delete Log file just to make sure we don't show an old error    On Error Resume Next        Kill LOG_FILE    On Error GoTo 0    ' ParameterSting with all paramters (AppleScriptTask only accepts a single parameter)    ParameterString = PYTHONPATH + ";"    ParameterString = ParameterString + "|" + PythonInterpreter    ParameterString = ParameterString + "|" + PythonCommand    ParameterString = ParameterString + "|" + ThisWorkbook.name    ParameterString = ParameterString + "|" + Left(Application.Path, Len(Application.Path) - 4)    ParameterString = ParameterString + "|" + LOG_FILE    On Error GoTo AppleScriptErrorHandler        ExitCode = AppleScriptTask("xlwings-" & XLWINGS_VERSION & ".applescript", "VbaHandler", ParameterString)    On Error GoTo 0    ' If there's a log at this point (normally that will be from the shell only, not Python) show it and reset the StatusBar    On Error Resume Next        Log = ReadFile(LOG_FILE)        If Log = "" Then            Exit Sub        Else            ShowError (LOG_FILE)            Application.StatusBar = False        End If        Exit Sub    On Error GoTo 0AppleScriptErrorHandler:    MsgBox "To enable RunPython, please run 'xlwings runpython install' in a terminal once and try again.", vbCritical    #End IfEnd SubFunction ExecuteWindows(IsFrozen As Boolean, PythonCommand As String, PYTHON_WIN As String, _                        Optional PYTHONPATH As String, Optional FrozenArgs As String) As Integer    ' Call a command window and change to the directory of the Python installation or frozen executable    ' Note: If Python is called from a different directory with the fully qualified path, pywintypesXX.dll won't be found.    ' This seems to be a general issue with pywin32, see http://stackoverflow.com/q/7238403/918626    Dim ShowConsole As Integer    Dim TempDir As String    If GetConfig("SHOW CONSOLE", False) = True Then        ShowConsole = 1    Else        ShowConsole = 0    End If    Dim Wsh As Object    Dim WaitOnReturn As Boolean: WaitOnReturn = True    Dim WindowStyle As Integer: WindowStyle = ShowConsole    Set Wsh = CreateObject("WScript.Shell")    Dim DriveCommand As String, RunCommand, condaExcecutable As String    Dim PythonInterpreter As String, PythonDir As String, CondaCmd As String, CondaPath As String, CondaEnv As String    Dim ExitCode As Long    Dim LOG_FILE As String        TempDir = GetConfig("TEMP DIR", Environ("Temp")) 'undocumented setting        LOG_FILE = TempDir & "\xlwings-" & CreateGUID() & ".log"    If Not IsFrozen And (PYTHON_WIN <> "python" And PYTHON_WIN <> "pythonw") Then        If FileExists(PYTHON_WIN) Then            PythonDir = ParentFolder(PYTHON_WIN)        Else            MsgBox "Could not find Interpreter!", vbCritical            Exit Function        End If    Else        PythonDir = ""  ' TODO: hack    End If    If Left$(PYTHON_WIN, 2) Like "[A-Za-z]:" Then        ' If Python is installed on a mapped or local drive, change to drive, then cd to path        DriveCommand = Left$(PYTHON_WIN, 2) & " & cd """ & PythonDir & """ & "    ElseIf Left$(PYTHON_WIN, 2) = "\\" Then        ' If Python is installed on a UNC path, temporarily mount and activate a drive letter with pushd        DriveCommand = "pushd """ & PythonDir & """ & "    End If    ' Run Python with the "-c" command line switch: add the path of the python file and run the    ' Command as first argument, then provide the Name and "from_xl" as 2nd and 3rd arguments.    ' Then redirect stderr to the LOG_FILE and wait for the call to return.    If PYTHON_WIN <> "python" And PYTHON_WIN <> "pythonw" Then        PythonInterpreter = Chr(34) & PYTHON_WIN & Chr(34)    Else        PythonInterpreter = "python"    End If    CondaPath = GetConfig("CONDA PATH")    CondaEnv = GetConfig("CONDA ENV")        ' Handle spaces in path (for UDFs, this is handled via nested quotes instead, see XLPyCommand)    CondaPath = Replace(CondaPath, " ", "^ ")        ' Handle ampersands and backslashes in file paths    PYTHONPATH = Replace(PYTHONPATH, "&", "^&")    PYTHONPATH = Replace(PYTHONPATH, "\", "\\")        If CondaPath <> "" And CondaEnv <> "" Then        If CheckConda(CondaPath) = False Then            Exit Function        End If        CondaCmd = CondaPath & "\condabin\conda activate " & CondaEnv & " && "    Else        CondaCmd = ""    End If    If IsFrozen = False Then        RunCommand = CondaCmd & PythonInterpreter & " -B -c ""import xlwings.utils;xlwings.utils.prepare_sys_path(\""" & PYTHONPATH & "\""); " & PythonCommand & """ "    ElseIf IsFrozen = True Then        RunCommand = Chr(34) & PythonCommand & Chr(34) & " " & FrozenArgs & " "    End If        ExitCode = Wsh.Run("cmd.exe /C " & DriveCommand & _                       RunCommand & _                       " --wb=" & """" & ThisWorkbook.name & """ --from_xl=1" & " --app=" & Chr(34) & _                       Application.Path & "\" & Application.name & Chr(34) & " --hwnd=" & Chr(34) & Application.Hwnd & Chr(34) & _                       " 2> """ & LOG_FILE & """ ", _                       WindowStyle, WaitOnReturn)    'If ExitCode <> 0 then there's something wrong    If ExitCode <> 0 Then        Call ShowError(LOG_FILE)        ExecuteWindows = -1    End If    ' Delete file after the error message has been shown    On Error Resume Next        Kill LOG_FILE    On Error GoTo 0    ' Clean up    Set Wsh = NothingEnd FunctionPublic Function RunFrozenPython(Executable As String, Optional Args As String)    ' Runs a Python executable that has been frozen by PyInstaller and the like. Call the function like this:    ' RunFrozenPython "C:\path\to\frozen_executable.exe", "arg1 arg2". Currently not implemented for Mac.    ' Call Python    #If Mac Then        MsgBox "This functionality is not yet supported on Mac." & vbNewLine & _               "Please run your scripts directly in Python!", vbCritical + vbOKOnly, "Unsupported Feature"    #Else        ExecuteWindows True, Executable, ParentFolder(Executable), , Args    #End IfEnd Function#If App = "Microsoft Excel" ThenFunction GetUdfModules(Optional wb As Workbook) As String#ElseFunction GetUdfModules(Optional wb As Variant) As String#End If    Dim i As Integer    Dim UDF_MODULES As String    Dim sht As Worksheet    GetUdfModules = GetConfig("UDF MODULES")    ' Remove trailing ";"    If Right$(GetUdfModules, 1) = ";" Then        GetUdfModules = Left$(GetUdfModules, Len(GetUdfModules) - 1)    End If        ' Automatically add embedded code sheets    For Each sht In wb.Worksheets        If Right$(sht.name, 3) = ".py" Then            If GetUdfModules = "" Then                GetUdfModules = Left$(sht.name, Len(sht.name) - 3)            Else                GetUdfModules = GetUdfModules & ";" & Left$(sht.name, Len(sht.name) - 3)            End If        End If    Next    ' Default    If GetUdfModules = "" Then        GetUdfModules = Left$(wb.name, Len(wb.name) - 5) ' assume that it ends in .xls*    End If    End FunctionPrivate Sub CleanUp()    'On Mac only, this function is being called after Python is done (using Python's atexit handler)    Dim LOG_FILE As String    #If MAC_OFFICE_VERSION >= 15 Then        LOG_FILE = Environ("HOME") + "/xlwings.log" '~/Library/Containers/com.microsoft.Excel/Data/xlwings.log    #Else        LOG_FILE = "/tmp/xlwings.log"    #End If    'Show the LOG_FILE as MsgBox if not empty    On Error Resume Next    If ReadFile(LOG_FILE) <> "" Then        Call ShowError(LOG_FILE)    End If    On Error GoTo 0    'Clean up    Application.StatusBar = False    Application.ScreenUpdating = True    On Error Resume Next        #If MAC_OFFICE_VERSION >= 15 Then            Kill LOG_FILE        #Else            KillFileOnMac ToMacPath(ToPosixPath(LOG_FILE))        #End If    On Error GoTo 0End SubFunction XLPyCommand()    'TODO: the whole python vs. pythonw should be obsolete now that the console is shown/hidden by the dll    Dim PYTHON_WIN As String, PYTHONPATH As String, LOG_FILE As String, tail As String, licenseKey As String, LicenseKeyEnvString As String    Dim CondaCmd As String, CondaPath As String, CondaEnv As String, ConsoleSwitch As String, FName As String    Dim DEBUG_UDFS As Boolean    #If App = "Microsoft Excel" Then    Dim wb As Workbook    #End If        ' The first 5 args are not technically part of the PYTHONPATH, but it's just easier to add it here (used by xlwings.utils.prepare_sys_path)    #If App = "Microsoft Excel" Then        PYTHONPATH = ThisWorkbook.FullName & ";" & ThisWorkbook.FullName & ";" & GetConfig("ONEDRIVE_CONSUMER_WIN") & ";" & GetConfig("ONEDRIVE_COMMERCIAL_WIN") & ";" & GetConfig("SHAREPOINT_WIN") & ";" & GetConfig("PYTHONPATH")    #Else        ' Other office apps        #If App = "Microsoft Word" Then            FName = ThisDocument.FullName        #ElseIf App = "Microsoft Access" Then            FName = CurrentProject.FullName        #ElseIf App = "Microsoft PowerPoint" Then            FName = ActivePresentation.FullName        #End If        PYTHONPATH = FName & ";" & ";" & GetConfig("ONEDRIVE_CONSUMER_WIN") & ";" & GetConfig("ONEDRIVE_COMMERCIAL_WIN") & ";" & GetConfig("SHAREPOINT_WIN") & ";" & GetConfig("PYTHONPATH")    #End If    ' Escaping backslashes and quotes    PYTHONPATH = Replace(PYTHONPATH, "\", "\\")    PYTHONPATH = Replace(PYTHONPATH, "'", "\'")    PYTHONPATH = Replace(PYTHONPATH, "&", "^&")        PYTHON_WIN = GetConfig("INTERPRETER_WIN", "")    If PYTHON_WIN = "" Then        ' Legacy        PYTHON_WIN = GetConfig("INTERPRETER", "pythonw")    End If    DEBUG_UDFS = GetConfig("DEBUG UDFS", False)    ' /showconsole is a ficticous command line switch that's ignored by cmd.exe but used by CreateProcessA in the dll    ' It's the only setting that's sent over like this at the moment    If GetConfig("SHOW CONSOLE", False) = True Then        ConsoleSwitch = "/showconsole"    Else        ConsoleSwitch = ""    End If    CondaPath = GetConfig("CONDA PATH")    CondaEnv = GetConfig("CONDA ENV")    If (PYTHON_WIN = "python" Or PYTHON_WIN = "pythonw") And (CondaPath <> "" And CondaEnv <> "") Then        CondaCmd = Chr(34) & Chr(34) & CondaPath & "\condabin\conda" & Chr(34) & " activate " & CondaEnv & " && "        PYTHON_WIN = "cmd.exe " & ConsoleSwitch & " /K " & CondaCmd & "python"    Else        PYTHON_WIN = "cmd.exe " & ConsoleSwitch & " /K " & PYTHON_WIN    End If    licenseKey = GetConfig("LICENSE_KEY", "")    If licenseKey <> "" Then        LicenseKeyEnvString = "os.environ['XLWINGS_LICENSE_KEY']='" & licenseKey & "';"    Else        LicenseKeyEnvString = ""    End If    If DEBUG_UDFS = True Then        XLPyCommand = "{506e67c3-55b5-48c3-a035-eed5deea7d6d}"    Else        tail = " -B -c ""import sys, os;" & LicenseKeyEnvString & "import xlwings.utils;xlwings.utils.prepare_sys_path(\""" & PYTHONPATH & "\"");import xlwings.server; xlwings.server.serve('$(CLSID)')"""        XLPyCommand = PYTHON_WIN & tail    End IfEnd FunctionPrivate Sub XLPyLoadDLL()    Dim PYTHON_WIN As String, CondaCmd As String, CondaPath As String, CondaEnv As String    PYTHON_WIN = GetConfig("INTERPRETER_WIN", "")    If PYTHON_WIN = "" Then        ' Legacy        PYTHON_WIN = GetConfig("INTERPRETER", "pythonw")    End If    CondaPath = GetConfig("CONDA PATH")    CondaEnv = GetConfig("CONDA ENV")    If (PYTHON_WIN = "python" Or PYTHON_WIN = "pythonw") And (CondaPath <> "" And CondaEnv <> "") Then        ' This only works if the envs are in their default location        ' Otherwise you'll have to add the full path for the interpreter in addition to the conda infos        If CondaEnv = "base" Then            PYTHON_WIN = CondaPath & "\" & PYTHON_WIN        Else            PYTHON_WIN = CondaPath & "\envs\" & CondaEnv & "\" & PYTHON_WIN        End If    End If    If (PYTHON_WIN <> "python" And PYTHON_WIN <> "pythonw") Or (CondaPath <> "" And CondaEnv <> "") Then        If LoadLibrary(ParentFolder(PYTHON_WIN) + "\" + XLPyDLLName) = 0 Then  ' Standard installation            If LoadLibrary(ParentFolder(ParentFolder(PYTHON_WIN)) + "\" + XLPyDLLName) = 0 Then  ' Virtualenv                err.Raise 1, Description:= _                    "Could not load " + XLPyDLLName + " from either of the following folders: " _                    + vbCrLf + ParentFolder(PYTHON_WIN) _                    + vbCrLf + ", " + ParentFolder(ParentFolder(PYTHON_WIN))            End If        End If    End IfEnd SubFunction NDims(ByRef src As Variant, dims As Long, Optional transpose As Boolean = False)    XLPyLoadDLL    If 0 <> XLPyDLLNDims(src, dims, transpose, NDims) Then err.Raise 1001, Description:=NDimsEnd FunctionFunction Py()    XLPyLoadDLL    If 0 <> XLPyDLLActivateAuto(Py, XLPyCommand, 1) Then err.Raise 1000, Description:=PyEnd FunctionSub KillPy()    XLPyLoadDLL    Dim unused    If 0 <> XLPyDLLActivateAuto(unused, XLPyCommand, -1) Then err.Raise 1000, Description:=unusedEnd SubSub ImportPythonUDFsBase(Optional addin As Boolean = False)    ' This is called from the Ribbon button    Dim tempPath As String, errorMsg As String    Dim wb As Workbook    If GetConfig("CONDA PATH") <> "" And CheckConda(GetConfig("CONDA PATH")) = False Then        Exit Sub    End If    If addin = True Then        Set wb = ThisWorkbook    Else        Set wb = ThisWorkbook    End If    On Error GoTo ImportError        tempPath = Py.Str(Py.Call(Py.Module("xlwings"), "import_udfs", Py.Tuple(GetUdfModules(wb), wb)))    Exit SubImportError:    errorMsg = err.Description & " " & err.Number    ShowError "", errorMsgEnd SubSub ImportPythonUDFs()    ImportPythonUDFsBaseEnd SubSub ImportPythonUDFsToAddin()    ImportPythonUDFsBase addin:=TrueEnd SubSub ImportXlwingsUdfsModule(tf As String)    ' Fallback: This is called from Python as direct pywin32 calls were sometimes failing, see comments in the Python code    On Error Resume Next    ThisWorkbook.VBProject.VBComponents.Remove ThisWorkbook.VBProject.VBComponents("xlwings_udfs")    On Error GoTo 0    ThisWorkbook.VBProject.VBComponents.Import tfEnd SubPrivate Sub GetDLLVersion()    ' Currently only for testing    Dim tag As String, arch As String    Dim ver As Double    XLPyDLLVersion tag, ver, arch    Debug.Print tag    Debug.Print ver    Debug.Print archEnd Sub'Attribute VB_Name = "Config"#If App = "Microsoft Excel" ThenFunction GetDirectoryPath(Optional wb As Workbook) As String#ElseFunction GetDirectoryPath(Optional wb As Variant) As String#End If    ' Leaving this here for now because we currently don't have #Const App in Utils    Dim Path As String    #If App = "Microsoft Excel" Then        On Error Resume Next 'On Mac, this is called when exiting the Python interpreter            Path = GetDirectory(GetFullName(wb))        On Error GoTo 0    #ElseIf App = "Microsoft Word" Then        Path = ThisDocument.Path    #ElseIf App = "Microsoft Access" Then        Path = CurrentProject.Path ' Won't be transformed for standalone module as ThisProject doesn't exit    #ElseIf App = "Microsoft PowerPoint" Then        Path = ActivePresentation.Path ' Won't be transformed for standalone module ThisPresentation doesn't exist    #Else        Exit Function    #End If    GetDirectoryPath = PathEnd FunctionFunction GetConfigFilePath() As String    #If Mac Then        ' ~/Library/Containers/com.microsoft.Excel/Data/xlwings.conf        GetConfigFilePath = GetMacDir("$HOME", False) & "/" & PROJECT_NAME & ".conf"    #Else        GetConfigFilePath = Environ("USERPROFILE") & "\." & PROJECT_NAME & "\" & PROJECT_NAME & ".conf"    #End IfEnd FunctionFunction GetDirectoryConfigFilePath() As String    Dim pathSeparator As String        #If Mac Then ' Application.PathSeparator doesn't seem to exist in Access...        pathSeparator = "/"    #Else        pathSeparator = "\"    #End If        GetDirectoryConfigFilePath = GetDirectoryPath(ThisWorkbook) & pathSeparator & PROJECT_NAME & ".conf"End Function#If App = "Microsoft Excel" ThenFunction GetConfigFromSheet(wb As Workbook)    Dim lastCell As Range, cell As Range    #If Mac Then    Dim d As Dictionary    Set d = New Dictionary    #Else    Dim d As Object    Set d = CreateObject("Scripting.Dictionary")    #End If    Dim sht As Worksheet    Set sht = wb.Sheets(PROJECT_NAME & ".conf")    If sht.Range("A2") = "" Then        Set lastCell = sht.Range("A1")    Else        Set lastCell = sht.Range("A1").End(xlDown)    End If    For Each cell In Range(sht.Range("A1"), lastCell)        d.Add UCase(cell.Value), cell.Offset(0, 1).Value    Next cell    Set GetConfigFromSheet = dEnd Function#End IfFunction GetConfig(configKey As String, Optional default As String = "", Optional source As String = "") As Variant    ' If source is provided, returns the value from this source only, otherwise it goes through all layers until    ' it finds a value (sheet -> directory -> user -> default)    ' An entry in xlwings.conf sheet overrides the config file/ribbon    Dim configValue As String        ' Sheet    #If App = "Microsoft Excel" Then    If source = "" Or source = "sheet" Then        If Application.name = "Microsoft Excel" Then            'Workbook Sheet Config            If SheetExists(ThisWorkbook, PROJECT_NAME & ".conf") = True Then                If GetConfigFromSheet(ThisWorkbook).Exists(configKey) = True Then                    GetConfig = GetConfigFromSheet(ThisWorkbook).Item(configKey)                    GetConfig = ExpandEnvironmentStrings(GetConfig)                    Exit Function                End If            End If                'Add-in Sheet Config (only for custom add-ins, unused by xlwings add-in)            If SheetExists(ThisWorkbook, PROJECT_NAME & ".conf") = True Then                If GetConfigFromSheet(ThisWorkbook).Exists(configKey) = True Then                    GetConfig = GetConfigFromSheet(ThisWorkbook).Item(configKey)                    GetConfig = ExpandEnvironmentStrings(GetConfig)                    Exit Function                End If            End If        End If    End If    #End If    ' Directory Config    If source = "" Or source = "directory" Then        #If App = "Microsoft Excel" Then            If GetFullName(ThisWorkbook) <> "" Then ' Empty if local dir can't be figured out (e.g. SharePoint)        #Else            If InStr(GetDirectoryPath(), "://") = 0 Then ' Other Office apps: skip for synced SharePoint/OneDrive files        #End If            If FileExists(GetDirectoryConfigFilePath()) = True Then                If GetConfigFromFile(GetDirectoryConfigFilePath(), configKey, configValue) Then                    GetConfig = configValue                    GetConfig = ExpandEnvironmentStrings(GetConfig)                    Exit Function                End If            End If        End If    End If    ' User Config    If source = "" Or source = "user" Then        If FileExists(GetConfigFilePath()) = True Then            If GetConfigFromFile(GetConfigFilePath(), configKey, configValue) Then                GetConfig = configValue                GetConfig = ExpandEnvironmentStrings(GetConfig)                Exit Function            End If        End If    End If    ' Defaults    GetConfig = default    GetConfig = ExpandEnvironmentStrings(GetConfig)End FunctionFunction SaveConfigToFile(sFileName As String, sName As String, Optional sValue As String) As Boolean'Adopted from http://peltiertech.com/save-retrieve-information-text-files/  Dim iFileNumA As Long, iFileNumB As Long, lErrLast As Long  Dim sFile As String, sXFile As String, sVarName As String, sVarValue As String            #If Mac Then    If Not FileOrFolderExistsOnMac(ParentFolder(sFileName)) Then  #Else    If Len(Dir(ParentFolder(sFileName), vbDirectory)) = 0 Then  #End If     MkDir ParentFolder(sFileName)  End If  ' assume false unless variable is successfully saved  SaveConfigToFile = False  ' temporary file  sFile = sFileName  sXFile = sFileName & "_temp"  ' open text file to read settings  If FileExists(sFile) Then    'replace existing settings file    iFileNumA = FreeFile    Open sFile For Input As iFileNumA    iFileNumB = FreeFile    Open sXFile For Output As iFileNumB      Do While Not EOF(iFileNumA)        Input #iFileNumA, sVarName, sVarValue        If sVarName <> sName Then          Write #iFileNumB, sVarName, sVarValue        End If      Loop      Write #iFileNumB, sName, sValue      SaveConfigToFile = True    Close #iFileNumA    Close #iFileNumB    FileCopy sXFile, sFile    Kill sXFile  Else    ' make new file    iFileNumB = FreeFile    Open sFile For Output As iFileNumB      Write #iFileNumB, sName, sValue      SaveConfigToFile = True    Close #iFileNumB  End IfEnd FunctionFunction GetConfigFromFile(sFile As String, sName As String, Optional sValue As String) As Boolean'Based on http://peltiertech.com/save-retrieve-information-text-files/  Dim iFileNum As Long, lErrLast As Long  Dim sVarName As String, sVarValue As String  ' assume false unless variable is found  GetConfigFromFile = False  ' open text file to read settings  If FileExists(sFile) Then    iFileNum = FreeFile    Open sFile For Input As iFileNum      Do While Not EOF(iFileNum)        Input #iFileNum, sVarName, sVarValue        If LCase(sVarName) = LCase(sName) Then          sValue = sVarValue          GetConfigFromFile = True          Exit Do        End If      Loop    Close #iFileNum  End IfEnd Function'Attribute VB_Name = "Extensions"Function sql(query, ParamArray tables())        If TypeOf Application.Caller Is Range Then On Error GoTo failed        ReDim argsArray(1 To UBound(tables) - LBound(tables) + 2)        argsArray(1) = query        For K = LBound(tables) To UBound(tables)        argsArray(2 + K - LBound(tables)) = tables(K)        Next K        If has_dynamic_array() Then            sql = Py.CallUDF("xlwings.ext", "sql_dynamic", argsArray, ThisWorkbook, Application.Caller)        Else            sql = Py.CallUDF("xlwings.ext", "sql", argsArray, ThisWorkbook, Application.Caller)        End If        Exit Functionfailed:        sql = err.DescriptionEnd Function'Attribute VB_Name = "Utils"Function IsFullName(sFile As String) As Boolean  ' if sFile includes path, it contains path separator "\" or "/"  IsFullName = InStr(sFile, "\") + InStr(sFile, "/") > 0End FunctionFunction FileExists(ByVal FileSpec As String) As Boolean    #If Mac Then        FileExists = FileOrFolderExistsOnMac(FileSpec)    #Else        FileExists = FileExistsOnWindows(FileSpec)    #End IfEnd FunctionFunction FileExistsOnWindows(ByVal FileSpec As String) As Boolean   ' by Karl Peterson MS MVP VB   Dim Attr As Long   ' Guard against bad FileSpec by ignoring errors   ' retrieving its attributes.   On Error Resume Next   Attr = GetAttr(FileSpec)   If err.Number = 0 Then      ' No error, so something was found.      ' If Directory attribute set, then not a file.      FileExistsOnWindows = Not ((Attr And vbDirectory) = vbDirectory)   End IfEnd FunctionFunction FileOrFolderExistsOnMac(FileOrFolderstr As String) As Boolean'Ron de Bruin : 26-June-2015'Function to test whether a file or folder exist on a Mac in office 2011 and up'Uses AppleScript to avoid the problem with long names in Office 2011,'limit is max 32 characters including the extension in 2011.    Dim ScriptToCheckFileFolder As String    Dim TestStr As String        #If Mac Then    If Val(Application.VERSION) < 15 Then        ScriptToCheckFileFolder = "tell application " & Chr(34) & "System Events" & Chr(34) & _         "to return exists disk item (" & Chr(34) & FileOrFolderstr & Chr(34) & " as string)"        FileOrFolderExistsOnMac = MacScript(ScriptToCheckFileFolder)    Else        On Error Resume Next        TestStr = Dir(FileOrFolderstr, vbDirectory)        On Error GoTo 0        If Not TestStr = vbNullString Then FileOrFolderExistsOnMac = True    End If    #End IfEnd FunctionFunction ParentFolder(ByVal Folder)  #If Mac Then      ParentFolder = Left$(Folder, InStrRev(Folder, "/") - 1)  #Else      ParentFolder = Left$(Folder, InStrRev(Folder, "\") - 1)  #End IfEnd FunctionFunction GetDirectory(Path)    #If Mac Then    GetDirectory = Left(Path, InStrRev(Path, "/"))    #Else    GetDirectory = Left(Path, InStrRev(Path, "\"))    #End IfEnd FunctionFunction KillFileOnMac(Filestr As String)    'Ron de Bruin    '30-July-2012    'Delete files from a Mac.    'Uses AppleScript to avoid the problem with long file names (on 2011 only)    Dim ScriptToKillFile As String        #If Mac Then    ScriptToKillFile = "tell application " & Chr(34) & "Finder" & Chr(34) & Chr(13)    ScriptToKillFile = ScriptToKillFile & "do shell script ""rm "" & quoted form of posix path of " & Chr(34) & Filestr & Chr(34) & Chr(13)    ScriptToKillFile = ScriptToKillFile & "end tell"    On Error Resume Next        MacScript (ScriptToKillFile)    On Error GoTo 0    #End IfEnd FunctionFunction ToMacPath(PosixPath As String) As String    ' This function transforms a Posix Path into a MacOS Path    ' E.g. "/Users/<User>" --> "MacintoshHD:Users:<User>"    #If Mac Then    ToMacPath = MacScript("set mac_path to POSIX file " & Chr(34) & PosixPath & Chr(34) & " as string")    #End IfEnd FunctionFunction GetMacDir(name As String, Normalize As Boolean) As String    #If Mac Then        Select Case name            Case "$HOME"                name = "home folder"            Case "$APPLICATIONS"                name = "applications folder"            Case "$DOCUMENTS"                name = "documents folder"            Case "$DOWNLOADS"                name = "downloads folder"            Case "$DESKTOP"                name = "desktop folder"            Case "$TMPDIR"                name = "temporary items"        End Select        GetMacDir = MacScript("return POSIX path of (path to " & name & ") as string")        If Normalize = True Then            'Normalize Excel sandbox location            GetMacDir = Replace(GetMacDir, "/Library/Containers/com.microsoft.Excel/Data", "")        End If    #Else    #End IfEnd FunctionFunction ToPosixPath(ByVal MacPath As String) As String    'This function accepts relative paths with backward and forward slashes: ThisWorkbook & "\test"    ' E.g. "MacintoshHD:Users:<User>" --> "/Users/<User>"    Dim s As String    Dim LeadingSlash As Boolean        #If Mac Then    If MacPath = "" Then        ToPosixPath = ""    Else        ToPosixPath = Replace(MacPath, "\", "/")        ToPosixPath = MacScript("return POSIX path of (" & Chr(34) & MacPath & Chr(34) & ") as string")    End If    #End IfEnd FunctionSub ShowError(FileName As String, Optional message As String = "")    ' Shows a MsgBox with the content of a text file    Dim Content As String    Dim objShell    Dim ErrorSheet As Worksheet    Const OK_BUTTON_ERROR = 16    Const AUTO_DISMISS = 0        If message = "" Then        Content = ReadFile(FileName)    Else        Content = message    End If        If GetConfig("SHOW_ERROR_POPUPS", "True") = "False" Then        If SheetExists(ThisWorkbook, "Error") = False Then            Set ErrorSheet = ThisWorkbook.Sheets.Add()            ErrorSheet.name = "Error"        Else            Set ErrorSheet = ThisWorkbook.Sheets("Error")        End If        ErrorSheet.Range("A1").Value = Content    Else        #If Mac Then            MsgBox Content, vbCritical, "Error"        #Else            Content = Content & vbCrLf            Content = Content & "Press Ctrl+C to copy this message to the clipboard."                Set objShell = CreateObject("Wscript.Shell")            objShell.Popup Content, AUTO_DISMISS, "Error", OK_BUTTON_ERROR        #End If    End IfEnd SubFunction ExpandEnvironmentStrings(ByVal s As String)    ' Expand environment variables    Dim EnvString As String    Dim PathParts As Variant    Dim i As Integer    #If Mac Then        If Left(s, 1) = "$" Then            PathParts = Split(s, "/")            EnvString = PathParts(0)            ExpandEnvironmentStrings = GetMacDir(EnvString, True)            For i = 1 To UBound(PathParts)                If Right$(ExpandEnvironmentStrings, 1) = "/" Then                    ExpandEnvironmentStrings = ExpandEnvironmentStrings & PathParts(i)                Else                    ExpandEnvironmentStrings = ExpandEnvironmentStrings & "/" & PathParts(i)                End If            Next i        Else            ExpandEnvironmentStrings = s        End If    #Else        Dim objShell As Object        Set objShell = CreateObject("WScript.Shell")        ExpandEnvironmentStrings = objShell.ExpandEnvironmentStrings(s)        Set objShell = Nothing    #End IfEnd FunctionFunction ReadFile(ByVal FileName As String)    ' Read a text file    Dim Content As String    Dim Token As String    Dim FileNum As Integer    Dim objShell As Object    Dim LineBreak As Variant    #If Mac Then        FileName = ToMacPath(FileName)        LineBreak = vbLf    #Else        FileName = ExpandEnvironmentStrings(FileName)        LineBreak = vbCrLf    #End If    FileNum = FreeFile    Content = ""    ' Read Text File    Open FileName For Input As #FileNum        Do While Not EOF(FileNum)            Line Input #FileNum, Token            Content = Content & Token & LineBreak        Loop    Close #FileNum    ReadFile = ContentEnd Function#If App = "Microsoft Excel" ThenFunction SheetExists(wb As Workbook, sheetName As String) As Boolean    Dim sht As Worksheet    On Error Resume Next        Set sht = wb.Sheets(sheetName)    On Error GoTo 0    SheetExists = Not sht Is NothingEnd Function#End IfFunction GetBaseName(wb As String) As String    Dim extension As String    extension = LCase$(Right$(wb, 4))    If extension = ".xls" Or extension = ".xla" Or extension = ".xlt" Then        GetBaseName = Left$(wb, Len(wb) - 4)    Else        GetBaseName = Left$(wb, Len(wb) - 5)    End IfEnd FunctionFunction has_dynamic_array() As Boolean    has_dynamic_array = False    On Error GoTo ErrHandler        Application.WorksheetFunction.Unique ("dummy")        has_dynamic_array = True    Exit FunctionErrHandler:    has_dynamic_array = FalseEnd FunctionPublic Function CreateGUID() As String    Randomize Timer() + Application.Hwnd    ' https://stackoverflow.com/a/46474125/918626    Do While Len(CreateGUID) < 32        If Len(CreateGUID) = 16 Then            '17th character holds version information            CreateGUID = CreateGUID & Hex$(8 + CInt(Rnd * 3))        End If        CreateGUID = CreateGUID & Hex$(CInt(Rnd * 15))    Loop    CreateGUID = Mid(CreateGUID, 1, 8) & "-" & Mid(CreateGUID, 9, 4) & "-" & Mid(CreateGUID, 13, 4) & "-" & Mid(CreateGUID, 17, 4) & "-" & Mid(CreateGUID, 21, 12)End FunctionFunction CheckConda(CondaPath As String) As Boolean    ' Check if the conda executable exists.    ' If it doesn't, conda is too old and the Interpreter setting has to be used instead of Conda settings    Dim condaExecutable As String    Dim condaExists As Boolean    #If Mac Then        condaExecutable = CondaPath & "\condabin\conda"    #Else        condaExecutable = CondaPath & "\condabin\conda.bat"    #End If    ' Replace space escape character ^ to check if path exists    condaExists = FileExists(Replace(condaExecutable, "^", ""))    If condaExists = False And CondaPath <> "" Then        MsgBox "Your Conda version seems to be too old for the Conda settings. Use the Interpreter setting instead."    End If    CheckConda = condaExistsEnd Function#If App = "Microsoft Excel" ThenFunction GetFullName(wb As Workbook) As String    ' The only case where this is still used is for directory-based config files, otherwise this is now handled in Python    ' Unlike the Python version, this doesn't work for SharePoint and will just ignore a directory-based config file silently    Dim total_found, i_parsing, i_env_var, slash_number As Integer    Dim found_path, one_drive_path, full_path_name, this_found_path As String    ' In the majority of cases, ThisWorkbook.FullName will provide the path of the    ' Excel workbook correctly. Unfortunately, when the user is using OneDrive    ' this doesn't work. This function will attempt to find the LOCAL path.    ' This uses code from Daniel Guetta and    ' https://stackoverflow.com/questions/33734706/excels-fullname-property-with-onedrive        If InStr(wb.FullName, "://") = 0 Or wb.Path = "" Then        GetFullName = wb.FullName        Exit Function    End If            ' According to the link above, there are three possible environment variables    ' the user's OneDrive folder could be located in    '      "OneDriveCommercial", "OneDriveConsumer", "OneDrive"    '    ' Furthermore, there are two possible formats for OneDrive URLs    '    1. "https://companyName-my.sharepoint.com/personal/userName_domain_com/Documents" & file.FullName    '    2. "https://d.docs.live.net/d7bbaa#######1/" & file.FullName    ' In the first case, we can find the true path by just looking for everything after /Documents. In the    ' second, we need to look for the fourth slash in the URL    '    ' The code below will try every combination of the three environment variables above, and    ' each of the two methods of parsing the URL. The file is found in *exactly* one of those    ' locations, then we're good to go.    '    ' Note that this still leaves a gap - if this file (file A) is in a location that is NOT covered by the    ' eventualities above AND a file of the exact same name (file B) exists in one of the locations that is    ' covered above, then this function will identify File B's location as the location of this workbook,    ' which would be wrong    total_found = 0        For i_parsing = 1 To 2        If i_parsing = 1 Then            ' Parse using method 1 above; find /Documents and take everything after, INCLUDING the            ' leading slash            If InStr(1, wb.FullName, "/Documents") Then                full_path_name = Mid(wb.FullName, InStr(1, wb.FullName, "/Documents") + Len("/Documents"))            Else                full_path_name = ""            End If        Else            ' Parse using method 2; find everything after the fourth slash, including that fourth            ' slash            Dim i_pos As Integer                        ' Start at the last slash in https://            i_pos = 8            For slash_number = 1 To 2                i_pos = InStr(i_pos + 1, wb.FullName, "/")            Next slash_number                        full_path_name = Mid(wb.FullName, i_pos)        End If                ' Replace forward slahes with backslashes on Windows        full_path_name = Replace(full_path_name, "/", Application.pathSeparator)                        If full_path_name <> "" Then            #If Not Mac Then            For i_env_var = 1 To 3                    one_drive_path = Environ(Choose(i_env_var, "OneDriveCommercial", "OneDriveConsumer", "OneDrive"))                                    If (one_drive_path <> "") And FileExists(one_drive_path & full_path_name) Then                        this_found_path = one_drive_path & full_path_name                                                If this_found_path <> found_path Then                            total_found = total_found + 1                            found_path = this_found_path                        End If                    End If            Next i_env_var            #End If        End If    Next i_parsing            If total_found = 1 Then        GetFullName = found_path        Exit Function    End IfEnd Function#End If---------------------------------------------------

VBAProject(myproject.xlsm) -> Class Modules -> Dictionary
''' Dictionary v1.4.1' (c) Tim Hall - https://github.com/timhall/VBA-Dictionary'' Drop-in replacement for Scripting.Dictionary on Mac'' @author: tim.hall.engr@gmail.com' @license: MIT (http://www.opensource.org/licenses/mit-license.php'' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 'Option Explicit' --------------------------------------------- '' Constants and Private Variables' --------------------------------------------- '#Const UseScriptingDictionaryIfAvailable = True#If Mac Or Not UseScriptingDictionaryIfAvailable Then' dict_KeyValue 0: FormattedKey, 1: OriginalKey, 2: ValuePrivate dict_pKeyValues As CollectionPrivate dict_pKeys() As VariantPrivate dict_pItems() As VariantPrivate dict_pObjectKeys As CollectionPrivate dict_pCompareMode As CompareMethod#ElsePrivate dict_pDictionary As Object#End If' --------------------------------------------- '' Types' --------------------------------------------- 'Public Enum CompareMethod    BinaryCompare = VBA.vbBinaryCompare    TextCompare = VBA.vbTextCompare    DatabaseCompare = VBA.vbDatabaseCompareEnd Enum' --------------------------------------------- '' Properties' --------------------------------------------- 'Public Property Get CompareMode() As CompareMethod#If Mac Or Not UseScriptingDictionaryIfAvailable Then    CompareMode = dict_pCompareMode#Else    CompareMode = dict_pDictionary.CompareMode#End IfEnd PropertyPublic Property Let CompareMode(Value As CompareMethod)#If Mac Or Not UseScriptingDictionaryIfAvailable Then    If Me.Count > 0 Then        ' Can't change CompareMode for Dictionary that contains data        ' http://msdn.microsoft.com/en-us/library/office/gg278481(v=office.15).aspx        err.Raise 5 ' Invalid procedure call or argument    End If    dict_pCompareMode = Value#Else    dict_pDictionary.CompareMode = Value#End IfEnd PropertyPublic Property Get Count() As Long#If Mac Or Not UseScriptingDictionaryIfAvailable Then    Count = dict_pKeyValues.Count#Else    Count = dict_pDictionary.Count#End IfEnd PropertyPublic Property Get Item(Key As Variant) As Variant#If Mac Or Not UseScriptingDictionaryIfAvailable Then    Dim dict_KeyValue As Variant    dict_KeyValue = dict_GetKeyValue(Key)    If Not IsEmpty(dict_KeyValue) Then        If VBA.IsObject(dict_KeyValue(2)) Then            Set Item = dict_KeyValue(2)        Else            Item = dict_KeyValue(2)        End If    Else        ' Not found -> Returns Empty    End If#Else    If VBA.IsObject(dict_pDictionary.Item(Key)) Then        Set Item = dict_pDictionary.Item(Key)    Else        Item = dict_pDictionary.Item(Key)    End If#End IfEnd PropertyPublic Property Let Item(Key As Variant, Value As Variant)#If Mac Or Not UseScriptingDictionaryIfAvailable Then    If Me.Exists(Key) Then        dict_ReplaceKeyValue dict_GetKeyValue(Key), Key, Value    Else        dict_AddKeyValue Key, Value    End If#Else    dict_pDictionary.Item(Key) = Value#End IfEnd PropertyPublic Property Set Item(Key As Variant, Value As Variant)#If Mac Or Not UseScriptingDictionaryIfAvailable Then    If Me.Exists(Key) Then        dict_ReplaceKeyValue dict_GetKeyValue(Key), Key, Value    Else        dict_AddKeyValue Key, Value    End If#Else    Set dict_pDictionary.Item(Key) = Value#End IfEnd PropertyPublic Property Let Key(Previous As Variant, Updated As Variant)#If Mac Or Not UseScriptingDictionaryIfAvailable Then    Dim dict_KeyValue As Variant    dict_KeyValue = dict_GetKeyValue(Previous)    If Not VBA.IsEmpty(dict_KeyValue) Then        dict_ReplaceKeyValue dict_KeyValue, Updated, dict_KeyValue(2)    End If#Else    dict_pDictionary.Key(Previous) = Updated#End IfEnd Property' ============================================= '' Public Methods' ============================================= '''' Add an item with the given key'' @param {Variant} Key' @param {Variant} Item' --------------------------------------------- 'Public Sub Add(Key As Variant, Item As Variant)#If Mac Or Not UseScriptingDictionaryIfAvailable Then    If Not Me.Exists(Key) Then        dict_AddKeyValue Key, Item    Else        ' This key is already associated with an element of this collection        err.Raise 457    End If#Else    dict_pDictionary.Add Key, Item#End IfEnd Sub''' Check if an item exists for the given key'' @param {Variant} Key' @return {Boolean}' --------------------------------------------- 'Public Function Exists(Key As Variant) As Boolean#If Mac Or Not UseScriptingDictionaryIfAvailable Then    Exists = Not IsEmpty(dict_GetKeyValue(Key))#Else    Exists = dict_pDictionary.Exists(Key)#End IfEnd Function''' Get an array of all items'' @return {Variant}' --------------------------------------------- 'Public Function Items() As Variant#If Mac Or Not UseScriptingDictionaryIfAvailable Then    If Me.Count > 0 Then        Items = dict_pItems    Else        ' Split("") creates initialized empty array that matches Dictionary Keys and Items        Items = VBA.Split("")    End If#Else    Items = dict_pDictionary.Items#End IfEnd Function''' Get an array of all keys'' @return {Variant}' --------------------------------------------- 'Public Function Keys() As Variant#If Mac Or Not UseScriptingDictionaryIfAvailable Then    If Me.Count > 0 Then        Keys = dict_pKeys    Else        ' Split("") creates initialized empty array that matches Dictionary Keys and Items        Keys = VBA.Split("")    End If#Else    Keys = dict_pDictionary.Keys#End IfEnd Function''' Remove an item for the given key'' @param {Variant} Key' --------------------------------------------- 'Public Sub Remove(Key As Variant)#If Mac Or Not UseScriptingDictionaryIfAvailable Then    Dim dict_KeyValue As Variant    dict_KeyValue = dict_GetKeyValue(Key)    If Not VBA.IsEmpty(dict_KeyValue) Then        dict_RemoveKeyValue dict_KeyValue    Else        ' Application-defined or object-defined error        err.Raise 32811    End If#Else    dict_pDictionary.Remove Key#End IfEnd Sub''' Remove all items' --------------------------------------------- 'Public Sub RemoveAll()#If Mac Or Not UseScriptingDictionaryIfAvailable Then    Set dict_pKeyValues = New Collection    Erase dict_pKeys    Erase dict_pItems#Else    dict_pDictionary.RemoveAll#End IfEnd Sub' ============================================= '' Private Functions' ============================================= '#If Mac Or Not UseScriptingDictionaryIfAvailable ThenPrivate Function dict_GetKeyValue(dict_Key As Variant) As Variant    On Error Resume Next    dict_GetKeyValue = dict_pKeyValues(dict_GetFormattedKey(dict_Key))    err.ClearEnd FunctionPrivate Sub dict_AddKeyValue(dict_Key As Variant, dict_Value As Variant, Optional dict_Index As Long = -1)    If Me.Count = 0 Then        ReDim dict_pKeys(0 To 0)        ReDim dict_pItems(0 To 0)    Else        ReDim Preserve dict_pKeys(0 To UBound(dict_pKeys) + 1)        ReDim Preserve dict_pItems(0 To UBound(dict_pItems) + 1)    End If    Dim dict_FormattedKey As String    dict_FormattedKey = dict_GetFormattedKey(dict_Key)    If dict_Index >= 0 And dict_Index < dict_pKeyValues.Count Then        ' Shift keys/items after + including index into empty last slot        Dim dict_i As Long        For dict_i = UBound(dict_pKeys) To dict_Index + 1 Step -1            dict_pKeys(dict_i) = dict_pKeys(dict_i - 1)            If VBA.IsObject(dict_pItems(dict_i - 1)) Then                Set dict_pItems(dict_i) = dict_pItems(dict_i - 1)            Else                dict_pItems(dict_i) = dict_pItems(dict_i - 1)            End If        Next dict_i        ' Add key/item at index        dict_pKeys(dict_Index) = dict_Key        If VBA.IsObject(dict_Value) Then            Set dict_pItems(dict_Index) = dict_Value        Else            dict_pItems(dict_Index) = dict_Value        End If        ' Add key-value at proper index        dict_pKeyValues.Add Array(dict_FormattedKey, dict_Key, dict_Value), dict_FormattedKey, Before:=dict_Index + 1    Else        ' Add key-value as last item        If VBA.IsObject(dict_Key) Then            Set dict_pKeys(UBound(dict_pKeys)) = dict_Key        Else            dict_pKeys(UBound(dict_pKeys)) = dict_Key        End If        If VBA.IsObject(dict_Value) Then            Set dict_pItems(UBound(dict_pItems)) = dict_Value        Else            dict_pItems(UBound(dict_pItems)) = dict_Value        End If        dict_pKeyValues.Add Array(dict_FormattedKey, dict_Key, dict_Value), dict_FormattedKey    End IfEnd SubPrivate Sub dict_ReplaceKeyValue(dict_KeyValue As Variant, dict_Key As Variant, dict_Value As Variant)    Dim dict_Index As Long    Dim dict_i As Integer    dict_Index = dict_GetKeyIndex(dict_KeyValue(1))    ' Remove existing dict_Value    dict_RemoveKeyValue dict_KeyValue, dict_Index    ' Add new dict_Key dict_Value back    dict_AddKeyValue dict_Key, dict_Value, dict_IndexEnd SubPrivate Sub dict_RemoveKeyValue(dict_KeyValue As Variant, Optional ByVal dict_Index As Long = -1)    Dim dict_i As Long    If dict_Index = -1 Then        dict_Index = dict_GetKeyIndex(dict_KeyValue(1))    End If    If dict_Index >= 0 And dict_Index <= UBound(dict_pKeys) Then        ' Shift keys/items after index down        For dict_i = dict_Index To UBound(dict_pKeys) - 1            dict_pKeys(dict_i) = dict_pKeys(dict_i + 1)            If VBA.IsObject(dict_pItems(dict_i + 1)) Then                Set dict_pItems(dict_i) = dict_pItems(dict_i + 1)            Else                dict_pItems(dict_i) = dict_pItems(dict_i + 1)            End If        Next dict_i        ' Resize keys/items to remove empty slot        If UBound(dict_pKeys) = 0 Then            Erase dict_pKeys            Erase dict_pItems        Else            ReDim Preserve dict_pKeys(0 To UBound(dict_pKeys) - 1)            ReDim Preserve dict_pItems(0 To UBound(dict_pItems) - 1)        End If    End If    dict_pKeyValues.Remove dict_KeyValue(0)    dict_RemoveObjectKey dict_KeyValue(1)End SubPrivate Function dict_GetFormattedKey(dict_Key As Variant) As String    If VBA.IsObject(dict_Key) Then        dict_GetFormattedKey = dict_GetObjectKey(dict_Key)    ElseIf VarType(dict_Key) = VBA.vbBoolean Then        dict_GetFormattedKey = IIf(dict_Key, "-1__-1", "0__0")    ElseIf VarType(dict_Key) = VBA.vbString Then        dict_GetFormattedKey = dict_Key        If Me.CompareMode = CompareMethod.BinaryCompare Then            ' Collection does not have method of setting key comparison            ' So case-sensitive keys aren't supported by default            ' -> Approach: Append lowercase characters to original key            '    AbC -> AbC___b_, abc -> abc__abc, ABC -> ABC_____            Dim dict_Lowercase As String            dict_Lowercase = ""            Dim dict_i As Integer            Dim dict_Char As String            Dim dict_Ascii As Integer            For dict_i = 1 To VBA.Len(dict_GetFormattedKey)                dict_Char = VBA.Mid$(dict_GetFormattedKey, dict_i, 1)                dict_Ascii = VBA.Asc(dict_Char)                If dict_Ascii >= 97 And dict_Ascii <= 122 Then                    dict_Lowercase = dict_Lowercase & dict_Char                Else                    dict_Lowercase = dict_Lowercase & "_"                End If            Next dict_i            If dict_Lowercase <> "" Then                dict_GetFormattedKey = dict_GetFormattedKey & "__" & dict_Lowercase            End If        End If    Else        ' For numbers, add duplicate to distinguish from strings        ' ->  123  -> "123__123"        '    "123" -> "123"        dict_GetFormattedKey = VBA.CStr(dict_Key) & "__" & CStr(dict_Key)    End IfEnd FunctionPrivate Function dict_GetObjectKey(dict_ObjKey As Variant) As String    Dim dict_i As Integer    For dict_i = 1 To dict_pObjectKeys.Count        If dict_pObjectKeys.Item(dict_i) Is dict_ObjKey Then            dict_GetObjectKey = "__object__" & dict_i            Exit Function        End If    Next dict_i    dict_pObjectKeys.Add dict_ObjKey    dict_GetObjectKey = "__object__" & dict_pObjectKeys.CountEnd FunctionPrivate Sub dict_RemoveObjectKey(dict_ObjKey As Variant)    Dim dict_i As Integer    For dict_i = 1 To dict_pObjectKeys.Count        If dict_pObjectKeys.Item(dict_i) Is dict_ObjKey Then            dict_pObjectKeys.Remove dict_i            Exit Sub        End If    Next dict_iEnd SubPrivate Function dict_GetKeyIndex(dict_Key As Variant) As Long    Dim dict_i As Long    For dict_i = 0 To UBound(dict_pKeys)        If VBA.IsObject(dict_pKeys(dict_i)) And VBA.IsObject(dict_Key) Then            If dict_pKeys(dict_i) Is dict_Key Then                dict_GetKeyIndex = dict_i                Exit For            End If        ElseIf VBA.IsObject(dict_pKeys(dict_i)) Or VBA.IsObject(dict_Key) Then            ' Both need to be objects to check equality, skip        ElseIf dict_pKeys(dict_i) = dict_Key Then            dict_GetKeyIndex = dict_i            Exit For        End If    Next dict_iEnd Function#End IfPrivate Sub Class_Initialize()#If Mac Or Not UseScriptingDictionaryIfAvailable Then    Set dict_pKeyValues = New Collection    Erase dict_pKeys    Erase dict_pItems    Set dict_pObjectKeys = New Collection#Else    Set dict_pDictionary = CreateObject("Scripting.Dictionary")#End IfEnd SubPrivate Sub Class_Terminate()#If Mac Or Not UseScriptingDictionaryIfAvailable Then    Set dict_pKeyValues = Nothing    Set dict_pObjectKeys = Nothing#Else    Set dict_pDictionary = Nothing#End IfEnd Sub---------------------------------------------------
---------------------------------------------------

xlwings(xlwings.xlam) -> Modules -> Config


Option Explicit#Const App = "Microsoft Excel" 'Adjust when using outside of Excel#If App = "Microsoft Excel" ThenFunction GetDirectoryPath(Optional wb As Workbook) As String#ElseFunction GetDirectoryPath(Optional wb As Variant) As String#End If    ' Leaving this here for now because we currently don't have #Const App in Utils    Dim Path As String    #If App = "Microsoft Excel" Then        On Error Resume Next 'On Mac, this is called when exiting the Python interpreter            Path = GetDirectory(GetFullName(wb))        On Error GoTo 0    #ElseIf App = "Microsoft Word" Then        Path = ActiveDocument.Path    #ElseIf App = "Microsoft Access" Then        Path = CurrentProject.Path ' Won't be transformed for standalone module as ThisProject doesn't exit    #ElseIf App = "Microsoft PowerPoint" Then        Path = ActivePresentation.Path ' Won't be transformed for standalone module ThisPresentation doesn't exist    #Else        Exit Function    #End If    GetDirectoryPath = PathEnd FunctionFunction GetConfigFilePath() As String    #If Mac Then        ' ~/Library/Containers/com.microsoft.Excel/Data/xlwings.conf        GetConfigFilePath = GetMacDir("$HOME", False) & "/" & PROJECT_NAME & ".conf"    #Else        GetConfigFilePath = Environ("USERPROFILE") & "\." & PROJECT_NAME & "\" & PROJECT_NAME & ".conf"    #End IfEnd FunctionFunction GetDirectoryConfigFilePath() As String    Dim pathSeparator As String        #If Mac Then ' Application.PathSeparator doesn't seem to exist in Access...        pathSeparator = "/"    #Else        pathSeparator = "\"    #End If        GetDirectoryConfigFilePath = GetDirectoryPath(ActiveWorkbook) & pathSeparator & PROJECT_NAME & ".conf"End Function#If App = "Microsoft Excel" ThenFunction GetConfigFromSheet(wb As Workbook)    Dim lastCell As Range, cell As Range    #If Mac Then    Dim d As Dictionary    Set d = New Dictionary    #Else    Dim d As Object    Set d = CreateObject("Scripting.Dictionary")    #End If    Dim sht As Worksheet    Set sht = wb.Sheets(PROJECT_NAME & ".conf")    If sht.Range("A2") = "" Then        Set lastCell = sht.Range("A1")    Else        Set lastCell = sht.Range("A1").End(xlDown)    End If    For Each cell In Range(sht.Range("A1"), lastCell)        d.Add UCase(cell.Value), cell.Offset(0, 1).Value    Next cell    Set GetConfigFromSheet = dEnd Function#End IfFunction GetConfig(configKey As String, Optional default As String = "", Optional source As String = "") As Variant    ' If source is provided, returns the value from this source only, otherwise it goes through all layers until    ' it finds a value (sheet -> directory -> user -> default)    ' An entry in xlwings.conf sheet overrides the config file/ribbon    Dim configValue As String        ' Sheet    #If App = "Microsoft Excel" Then    If source = "" Or source = "sheet" Then        If Application.name = "Microsoft Excel" Then            'Workbook Sheet Config            If SheetExists(ActiveWorkbook, PROJECT_NAME & ".conf") = True Then                If GetConfigFromSheet(ActiveWorkbook).Exists(configKey) = True Then                    GetConfig = GetConfigFromSheet(ActiveWorkbook).Item(configKey)                    GetConfig = ExpandEnvironmentStrings(GetConfig)                    Exit Function                End If            End If                'Add-in Sheet Config (only for custom add-ins, unused by xlwings add-in)            If SheetExists(ThisWorkbook, PROJECT_NAME & ".conf") = True Then                If GetConfigFromSheet(ThisWorkbook).Exists(configKey) = True Then                    GetConfig = GetConfigFromSheet(ThisWorkbook).Item(configKey)                    GetConfig = ExpandEnvironmentStrings(GetConfig)                    Exit Function                End If            End If        End If    End If    #End If    ' Directory Config    If source = "" Or source = "directory" Then        #If App = "Microsoft Excel" Then            If GetFullName(ActiveWorkbook) <> "" Then ' Empty if local dir can't be figured out (e.g. SharePoint)        #Else            If InStr(GetDirectoryPath(), "://") = 0 Then ' Other Office apps: skip for synced SharePoint/OneDrive files        #End If            If FileExists(GetDirectoryConfigFilePath()) = True Then                If GetConfigFromFile(GetDirectoryConfigFilePath(), configKey, configValue) Then                    GetConfig = configValue                    GetConfig = ExpandEnvironmentStrings(GetConfig)                    Exit Function                End If            End If        End If    End If    ' User Config    If source = "" Or source = "user" Then        If FileExists(GetConfigFilePath()) = True Then            If GetConfigFromFile(GetConfigFilePath(), configKey, configValue) Then                GetConfig = configValue                GetConfig = ExpandEnvironmentStrings(GetConfig)                Exit Function            End If        End If    End If    ' Defaults    GetConfig = default    GetConfig = ExpandEnvironmentStrings(GetConfig)End FunctionFunction SaveConfigToFile(sFileName As String, sName As String, Optional sValue As String) As Boolean'Adopted from http://peltiertech.com/save-retrieve-information-text-files/  Dim iFileNumA As Long, iFileNumB As Long, lErrLast As Long  Dim sFile As String, sXFile As String, sVarName As String, sVarValue As String            #If Mac Then    If Not FileOrFolderExistsOnMac(ParentFolder(sFileName)) Then  #Else    If Len(Dir(ParentFolder(sFileName), vbDirectory)) = 0 Then  #End If     MkDir ParentFolder(sFileName)  End If  ' assume false unless variable is successfully saved  SaveConfigToFile = False  ' temporary file  sFile = sFileName  sXFile = sFileName & "_temp"  ' open text file to read settings  If FileExists(sFile) Then    'replace existing settings file    iFileNumA = FreeFile    Open sFile For Input As iFileNumA    iFileNumB = FreeFile    Open sXFile For Output As iFileNumB      Do While Not EOF(iFileNumA)        Input #iFileNumA, sVarName, sVarValue        If sVarName <> sName Then          Write #iFileNumB, sVarName, sVarValue        End If      Loop      Write #iFileNumB, sName, sValue      SaveConfigToFile = True    Close #iFileNumA    Close #iFileNumB    FileCopy sXFile, sFile    Kill sXFile  Else    ' make new file    iFileNumB = FreeFile    Open sFile For Output As iFileNumB      Write #iFileNumB, sName, sValue      SaveConfigToFile = True    Close #iFileNumB  End IfEnd FunctionFunction GetConfigFromFile(sFile As String, sName As String, Optional sValue As String) As Boolean'Based on http://peltiertech.com/save-retrieve-information-text-files/  Dim iFileNum As Long, lErrLast As Long  Dim sVarName As String, sVarValue As String  ' assume false unless variable is found  GetConfigFromFile = False  ' open text file to read settings  If FileExists(sFile) Then    iFileNum = FreeFile    Open sFile For Input As iFileNum      Do While Not EOF(iFileNum)        Input #iFileNum, sVarName, sVarValue        If LCase(sVarName) = LCase(sName) Then          sValue = sVarValue          GetConfigFromFile = True          Exit Do        End If      Loop    Close #iFileNum  End IfEnd Function---------------------------------------------------

xlwings(xlwings.xlam) -> Modules -> Extensions

Function sql(query, ParamArray tables())        If TypeOf Application.Caller Is Range Then On Error GoTo failed        ReDim argsArray(1 To UBound(tables) - LBound(tables) + 2)        argsArray(1) = query        For K = LBound(tables) To UBound(tables)        argsArray(2 + K - LBound(tables)) = tables(K)        Next K        If has_dynamic_array() Then            sql = Py.CallUDF("xlwings.ext", "sql_dynamic", argsArray, ActiveWorkbook, Application.Caller)        Else            sql = Py.CallUDF("xlwings.ext", "sql", argsArray, ActiveWorkbook, Application.Caller)        End If        Exit Functionfailed:        sql = Err.DescriptionEnd Function
---------------------------------------------------

xlwings(xlwings.xlam) -> Modules -> Main

Option Explicit#Const App = "Microsoft Excel" 'Adjust when using outside of Excel#If VBA7 Then    #If Mac Then        Private Declare PtrSafe Function system Lib "libc.dylib" (ByVal Command As String) As Long    #End If    #If Win64 Then        Const XLPyDLLName As String = "xlwings64-0.25.3.dll"        Declare PtrSafe Function XLPyDLLActivateAuto Lib "xlwings64-0.25.3.dll" (ByRef result As Variant, Optional ByVal Config As String = "", Optional ByVal mode As Long = 1) As Long        Declare PtrSafe Function XLPyDLLNDims Lib "xlwings64-0.25.3.dll" (ByRef src As Variant, ByRef dims As Long, ByRef transpose As Boolean, ByRef dest As Variant) As Long        Declare PtrSafe Function XLPyDLLVersion Lib "xlwings64-0.25.3.dll" (tag As String, VERSION As Double, arch As String) As Long    #Else        Private Const XLPyDLLName As String = "xlwings32-0.25.3.dll"        Declare PtrSafe Function XLPyDLLActivateAuto Lib "xlwings32-0.25.3.dll" (ByRef result As Variant, Optional ByVal Config As String = "", Optional ByVal mode As Long = 1) As Long        Private Declare PtrSafe Function XLPyDLLNDims Lib "xlwings32-0.25.3.dll" (ByRef src As Variant, ByRef dims As Long, ByRef transpose As Boolean, ByRef dest As Variant) As Long        Private Declare PtrSafe Function XLPyDLLVersion Lib "xlwings32-0.25.3.dll" (tag As String, VERSION As Double, arch As String) As Long    #End If    Private Declare PtrSafe Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long#Else    #If Mac Then        Private Declare Function system Lib "libc.dylib" (ByVal Command As String) As Long    #End If    Private Const XLPyDLLName As String = "xlwings32-0.25.3.dll"    Private Declare Function XLPyDLLActivateAuto Lib "xlwings32-0.25.3.dll" (ByRef result As Variant, Optional ByVal Config As String = "", Optional ByVal mode As Long = 1) As Long    Private Declare Function XLPyDLLNDims Lib "xlwings32-0.25.3.dll" (ByRef src As Variant, ByRef dims As Long, ByRef transpose As Boolean, ByRef dest As Variant) As Long    Private Declare Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long    Declare Function XLPyDLLVersion Lib "xlwings32-0.25.3.dll" (tag As String, VERSION As Double, arch As String) As Long#End IfPublic Const XLWINGS_VERSION As String = "0.25.3"Public Const PROJECT_NAME As String = "xlwings"Public Function RunPython(PythonCommand As String)    ' Public API: Runs the Python command, e.g.: to run the function foo() in module bar, call the function like this:    ' RunPython "import bar; bar.foo()"        Dim i As Integer    Dim SourcePythonCommand As String, interpreter As String, PYTHONPATH As String, licenseKey, ActiveFullName As String, ThisFullName As String    Dim OPTIMIZED_CONNECTION As Boolean, uses_embedded_code As Boolean    Dim wb As Workbook    Dim sht As Worksheet        SourcePythonCommand = PythonCommand        #If Mac Then        interpreter = GetConfig("INTERPRETER_MAC", "")    #Else        interpreter = GetConfig("INTERPRETER_WIN", "")    #End If    If interpreter = "" Then        ' Legacy        interpreter = GetConfig("INTERPRETER", "python")    End If        ' The first 5 args are not technically part of the PYTHONPATH, but it's just easier to add it here (used by xlwings.utils.prepare_sys_path)    #If Mac Then        If InStr(ActiveWorkbook.FullName, "://") = 0 Then            ActiveFullName = ToPosixPath(ActiveWorkbook.FullName)            ThisFullName = ToPosixPath(ThisWorkbook.FullName)        Else            ActiveFullName = ActiveWorkbook.FullName            ThisFullName = ThisWorkbook.FullName        End If    #Else        ActiveFullName = ActiveWorkbook.FullName        ThisFullName = ThisWorkbook.FullName    #End If        #If Mac Then        PYTHONPATH = ActiveFullName & ";" & ThisFullName & ";" & GetConfig("ONEDRIVE_CONSUMER_MAC") & ";" & GetConfig("ONEDRIVE_COMMERCIAL_MAC") & ";" & GetConfig("SHAREPOINT_MAC") & ";" & GetConfig("PYTHONPATH")    #Else        PYTHONPATH = ActiveFullName & ";" & ThisFullName & ";" & GetConfig("ONEDRIVE_CONSUMER_WIN") & ";" & GetConfig("ONEDRIVE_COMMERCIAL_WIN") & ";" & GetConfig("SHAREPOINT_WIN") & ";" & GetConfig("PYTHONPATH")    #End If    OPTIMIZED_CONNECTION = GetConfig("USE UDF SERVER", False)    ' Handle embedded Python code    uses_embedded_code = False    For i = 1 To 2        If i = 1 Then            Set wb = ActiveWorkbook        Else            Set wb = ThisWorkbook        End If        For Each sht In wb.Worksheets            If Right$(sht.name, 3) = ".py" Then                uses_embedded_code = True                Exit For            End If        Next    Next i    If uses_embedded_code = True Then        licenseKey = GetConfig("LICENSE_KEY")        If licenseKey = "" Then            MsgBox "Embedded code requires a valid LICENSE_KEY."            Exit Function        Else            PythonCommand = "import xlwings.pro;xlwings.pro.runpython_embedded_code('" & SourcePythonCommand & "')"        End If    End If    ' Handle module execute permission (for embedded code that happens in Python)    If LCase(GetConfig("PERMISSION_CHECK_ENABLED", , source:="user")) = "true" And uses_embedded_code = False Then        PythonCommand = "import xlwings.pro;xlwings.pro.verify_execute_permission('" & SourcePythonCommand & "');" & PythonCommand    End If    ' Call Python platform-dependent    #If Mac Then        Application.StatusBar = "Running..."  ' Non-blocking way of giving feedback that something is happening        ExecuteMac PythonCommand, interpreter, PYTHONPATH    #Else        If OPTIMIZED_CONNECTION = True Then            Py.SetAttr Py.Module("xlwings._xlwindows"), "BOOK_CALLER", ActiveWorkbook                        On Error GoTo err_handling                        Py.Exec "" & PythonCommand & ""            GoTo end_err_handlingerr_handling:            ShowError "", Err.Description            RunPython = -1            On Error GoTo 0end_err_handling:        Else            RunPython = ExecuteWindows(False, PythonCommand, interpreter, PYTHONPATH)        End If    #End IfEnd FunctionSub ExecuteMac(PythonCommand As String, PYTHON_MAC As String, Optional PYTHONPATH As String)    #If Mac Then    Dim PythonInterpreter As String, RunCommand As String, Log As String    Dim ParameterString As String, ExitCode As String, CondaCmd As String, CondaPath As String, CondaEnv As String, LOG_FILE As String    ' Transform paths    PYTHONPATH = Replace(PYTHONPATH, "'", "\'") ' Escaping quotes    If PYTHON_MAC <> "" Then        If PYTHON_MAC <> "python" And PYTHON_MAC <> "pythonw" Then            PythonInterpreter = ToPosixPath(PYTHON_MAC)        Else            PythonInterpreter = PYTHON_MAC        End If    Else        PythonInterpreter = "python"    End If    ' Sandbox location that requires no file access confirmation    ' TODO: Use same logic with GUID like for Windows. Only here the GUID will need to be passed back to CleanUp()    LOG_FILE = Environ("HOME") + "/xlwings.log" '/Users/<User>/Library/Containers/com.microsoft.Excel/Data/xlwings.log    ' Delete Log file just to make sure we don't show an old error    On Error Resume Next        Kill LOG_FILE    On Error GoTo 0    ' ParameterSting with all paramters (AppleScriptTask only accepts a single parameter)    ParameterString = PYTHONPATH + ";"    ParameterString = ParameterString + "|" + PythonInterpreter    ParameterString = ParameterString + "|" + PythonCommand    ParameterString = ParameterString + "|" + ActiveWorkbook.name    ParameterString = ParameterString + "|" + Left(Application.Path, Len(Application.Path) - 4)    ParameterString = ParameterString + "|" + LOG_FILE    On Error GoTo AppleScriptErrorHandler        ExitCode = AppleScriptTask("xlwings-" & XLWINGS_VERSION & ".applescript", "VbaHandler", ParameterString)    On Error GoTo 0    ' If there's a log at this point (normally that will be from the shell only, not Python) show it and reset the StatusBar    On Error Resume Next        Log = ReadFile(LOG_FILE)        If Log = "" Then            Exit Sub        Else            ShowError (LOG_FILE)            Application.StatusBar = False        End If        Exit Sub    On Error GoTo 0AppleScriptErrorHandler:    MsgBox "To enable RunPython, please run 'xlwings runpython install' in a terminal once and try again.", vbCritical    #End IfEnd SubFunction ExecuteWindows(IsFrozen As Boolean, PythonCommand As String, PYTHON_WIN As String, _                        Optional PYTHONPATH As String, Optional FrozenArgs As String) As Integer    ' Call a command window and change to the directory of the Python installation or frozen executable    ' Note: If Python is called from a different directory with the fully qualified path, pywintypesXX.dll won't be found.    ' This seems to be a general issue with pywin32, see http://stackoverflow.com/q/7238403/918626    Dim ShowConsole As Integer    Dim TempDir As String    If GetConfig("SHOW CONSOLE", False) = True Then        ShowConsole = 1    Else        ShowConsole = 0    End If    Dim Wsh As Object    Dim WaitOnReturn As Boolean: WaitOnReturn = True    Dim WindowStyle As Integer: WindowStyle = ShowConsole    Set Wsh = CreateObject("WScript.Shell")    Dim DriveCommand As String, RunCommand, condaExcecutable As String    Dim PythonInterpreter As String, PythonDir As String, CondaCmd As String, CondaPath As String, CondaEnv As String    Dim ExitCode As Long    Dim LOG_FILE As String        TempDir = GetConfig("TEMP DIR", Environ("Temp")) 'undocumented setting        LOG_FILE = TempDir & "\xlwings-" & CreateGUID() & ".log"    If Not IsFrozen And (PYTHON_WIN <> "python" And PYTHON_WIN <> "pythonw") Then        If FileExists(PYTHON_WIN) Then            PythonDir = ParentFolder(PYTHON_WIN)        Else            MsgBox "Could not find Interpreter!", vbCritical            Exit Function        End If    Else        PythonDir = ""  ' TODO: hack    End If    If Left$(PYTHON_WIN, 2) Like "[A-Za-z]:" Then        ' If Python is installed on a mapped or local drive, change to drive, then cd to path        DriveCommand = Left$(PYTHON_WIN, 2) & " & cd """ & PythonDir & """ & "    ElseIf Left$(PYTHON_WIN, 2) = "\\" Then        ' If Python is installed on a UNC path, temporarily mount and activate a drive letter with pushd        DriveCommand = "pushd """ & PythonDir & """ & "    End If    ' Run Python with the "-c" command line switch: add the path of the python file and run the    ' Command as first argument, then provide the Name and "from_xl" as 2nd and 3rd arguments.    ' Then redirect stderr to the LOG_FILE and wait for the call to return.    If PYTHON_WIN <> "python" And PYTHON_WIN <> "pythonw" Then        PythonInterpreter = Chr(34) & PYTHON_WIN & Chr(34)    Else        PythonInterpreter = "python"    End If    CondaPath = GetConfig("CONDA PATH")    CondaEnv = GetConfig("CONDA ENV")        ' Handle spaces in path (for UDFs, this is handled via nested quotes instead, see XLPyCommand)    CondaPath = Replace(CondaPath, " ", "^ ")        ' Handle ampersands and backslashes in file paths    PYTHONPATH = Replace(PYTHONPATH, "&", "^&")    PYTHONPATH = Replace(PYTHONPATH, "\", "\\")        If CondaPath <> "" And CondaEnv <> "" Then        If CheckConda(CondaPath) = False Then            Exit Function        End If        CondaCmd = CondaPath & "\condabin\conda activate " & CondaEnv & " && "    Else        CondaCmd = ""    End If    If IsFrozen = False Then        RunCommand = CondaCmd & PythonInterpreter & " -B -c ""import xlwings.utils;xlwings.utils.prepare_sys_path(\""" & PYTHONPATH & "\""); " & PythonCommand & """ "    ElseIf IsFrozen = True Then        RunCommand = Chr(34) & PythonCommand & Chr(34) & " " & FrozenArgs & " "    End If        ExitCode = Wsh.Run("cmd.exe /C " & DriveCommand & _                       RunCommand & _                       " --wb=" & """" & ActiveWorkbook.name & """ --from_xl=1" & " --app=" & Chr(34) & _                       Application.Path & "\" & Application.name & Chr(34) & " --hwnd=" & Chr(34) & Application.Hwnd & Chr(34) & _                       " 2> """ & LOG_FILE & """ ", _                       WindowStyle, WaitOnReturn)    'If ExitCode <> 0 then there's something wrong    If ExitCode <> 0 Then        Call ShowError(LOG_FILE)        ExecuteWindows = -1    End If    ' Delete file after the error message has been shown    On Error Resume Next        Kill LOG_FILE    On Error GoTo 0    ' Clean up    Set Wsh = NothingEnd FunctionPublic Function RunFrozenPython(Executable As String, Optional Args As String)    ' Runs a Python executable that has been frozen by PyInstaller and the like. Call the function like this:    ' RunFrozenPython "C:\path\to\frozen_executable.exe", "arg1 arg2". Currently not implemented for Mac.    ' Call Python    #If Mac Then        MsgBox "This functionality is not yet supported on Mac." & vbNewLine & _               "Please run your scripts directly in Python!", vbCritical + vbOKOnly, "Unsupported Feature"    #Else        ExecuteWindows True, Executable, ParentFolder(Executable), , Args    #End IfEnd Function#If App = "Microsoft Excel" ThenFunction GetUdfModules(Optional wb As Workbook) As String#ElseFunction GetUdfModules(Optional wb As Variant) As String#End If    Dim i As Integer    Dim UDF_MODULES As String    Dim sht As Worksheet    GetUdfModules = GetConfig("UDF MODULES")    ' Remove trailing ";"    If Right$(GetUdfModules, 1) = ";" Then        GetUdfModules = Left$(GetUdfModules, Len(GetUdfModules) - 1)    End If        ' Automatically add embedded code sheets    For Each sht In wb.Worksheets        If Right$(sht.name, 3) = ".py" Then            If GetUdfModules = "" Then                GetUdfModules = Left$(sht.name, Len(sht.name) - 3)            Else                GetUdfModules = GetUdfModules & ";" & Left$(sht.name, Len(sht.name) - 3)            End If        End If    Next    ' Default    If GetUdfModules = "" Then        GetUdfModules = Left$(wb.name, Len(wb.name) - 5) ' assume that it ends in .xls*    End If    End FunctionPrivate Sub CleanUp()    'On Mac only, this function is being called after Python is done (using Python's atexit handler)    Dim LOG_FILE As String    #If MAC_OFFICE_VERSION >= 15 Then        LOG_FILE = Environ("HOME") + "/xlwings.log" '~/Library/Containers/com.microsoft.Excel/Data/xlwings.log    #Else        LOG_FILE = "/tmp/xlwings.log"    #End If    'Show the LOG_FILE as MsgBox if not empty    On Error Resume Next    If ReadFile(LOG_FILE) <> "" Then        Call ShowError(LOG_FILE)    End If    On Error GoTo 0    'Clean up    Application.StatusBar = False    Application.ScreenUpdating = True    On Error Resume Next        #If MAC_OFFICE_VERSION >= 15 Then            Kill LOG_FILE        #Else            KillFileOnMac ToMacPath(ToPosixPath(LOG_FILE))        #End If    On Error GoTo 0End SubFunction XLPyCommand()    'TODO: the whole python vs. pythonw should be obsolete now that the console is shown/hidden by the dll    Dim PYTHON_WIN As String, PYTHONPATH As String, LOG_FILE As String, tail As String, licenseKey As String, LicenseKeyEnvString As String    Dim CondaCmd As String, CondaPath As String, CondaEnv As String, ConsoleSwitch As String, FName As String    Dim DEBUG_UDFS As Boolean    #If App = "Microsoft Excel" Then    Dim wb As Workbook    #End If        ' The first 5 args are not technically part of the PYTHONPATH, but it's just easier to add it here (used by xlwings.utils.prepare_sys_path)    #If App = "Microsoft Excel" Then        PYTHONPATH = ActiveWorkbook.FullName & ";" & ThisWorkbook.FullName & ";" & GetConfig("ONEDRIVE_CONSUMER_WIN") & ";" & GetConfig("ONEDRIVE_COMMERCIAL_WIN") & ";" & GetConfig("SHAREPOINT_WIN") & ";" & GetConfig("PYTHONPATH")    #Else        ' Other office apps        #If App = "Microsoft Word" Then            FName = ThisDocument.FullName        #ElseIf App = "Microsoft Access" Then            FName = CurrentProject.FullName        #ElseIf App = "Microsoft PowerPoint" Then            FName = ActivePresentation.FullName        #End If        PYTHONPATH = FName & ";" & ";" & GetConfig("ONEDRIVE_CONSUMER_WIN") & ";" & GetConfig("ONEDRIVE_COMMERCIAL_WIN") & ";" & GetConfig("SHAREPOINT_WIN") & ";" & GetConfig("PYTHONPATH")    #End If    ' Escaping backslashes and quotes    PYTHONPATH = Replace(PYTHONPATH, "\", "\\")    PYTHONPATH = Replace(PYTHONPATH, "'", "\'")    PYTHONPATH = Replace(PYTHONPATH, "&", "^&")        PYTHON_WIN = GetConfig("INTERPRETER_WIN", "")    If PYTHON_WIN = "" Then        ' Legacy        PYTHON_WIN = GetConfig("INTERPRETER", "pythonw")    End If    DEBUG_UDFS = GetConfig("DEBUG UDFS", False)    ' /showconsole is a ficticous command line switch that's ignored by cmd.exe but used by CreateProcessA in the dll    ' It's the only setting that's sent over like this at the moment    If GetConfig("SHOW CONSOLE", False) = True Then        ConsoleSwitch = "/showconsole"    Else        ConsoleSwitch = ""    End If    CondaPath = GetConfig("CONDA PATH")    CondaEnv = GetConfig("CONDA ENV")    If (PYTHON_WIN = "python" Or PYTHON_WIN = "pythonw") And (CondaPath <> "" And CondaEnv <> "") Then        CondaCmd = Chr(34) & Chr(34) & CondaPath & "\condabin\conda" & Chr(34) & " activate " & CondaEnv & " && "        PYTHON_WIN = "cmd.exe " & ConsoleSwitch & " /K " & CondaCmd & "python"    Else        PYTHON_WIN = "cmd.exe " & ConsoleSwitch & " /K " & PYTHON_WIN    End If    licenseKey = GetConfig("LICENSE_KEY", "")    If licenseKey <> "" Then        LicenseKeyEnvString = "os.environ['XLWINGS_LICENSE_KEY']='" & licenseKey & "';"    Else        LicenseKeyEnvString = ""    End If    If DEBUG_UDFS = True Then        XLPyCommand = "{506e67c3-55b5-48c3-a035-eed5deea7d6d}"    Else        tail = " -B -c ""import sys, os;" & LicenseKeyEnvString & "import xlwings.utils;xlwings.utils.prepare_sys_path(\""" & PYTHONPATH & "\"");import xlwings.server; xlwings.server.serve('$(CLSID)')"""        XLPyCommand = PYTHON_WIN & tail    End IfEnd FunctionPrivate Sub XLPyLoadDLL()    Dim PYTHON_WIN As String, CondaCmd As String, CondaPath As String, CondaEnv As String    PYTHON_WIN = GetConfig("INTERPRETER_WIN", "")    If PYTHON_WIN = "" Then        ' Legacy        PYTHON_WIN = GetConfig("INTERPRETER", "pythonw")    End If    CondaPath = GetConfig("CONDA PATH")    CondaEnv = GetConfig("CONDA ENV")    If (PYTHON_WIN = "python" Or PYTHON_WIN = "pythonw") And (CondaPath <> "" And CondaEnv <> "") Then        ' This only works if the envs are in their default location        ' Otherwise you'll have to add the full path for the interpreter in addition to the conda infos        If CondaEnv = "base" Then            PYTHON_WIN = CondaPath & "\" & PYTHON_WIN        Else            PYTHON_WIN = CondaPath & "\envs\" & CondaEnv & "\" & PYTHON_WIN        End If    End If    If (PYTHON_WIN <> "python" And PYTHON_WIN <> "pythonw") Or (CondaPath <> "" And CondaEnv <> "") Then        If LoadLibrary(ParentFolder(PYTHON_WIN) + "\" + XLPyDLLName) = 0 Then  ' Standard installation            If LoadLibrary(ParentFolder(ParentFolder(PYTHON_WIN)) + "\" + XLPyDLLName) = 0 Then  ' Virtualenv                Err.Raise 1, Description:= _                    "Could not load " + XLPyDLLName + " from either of the following folders: " _                    + vbCrLf + ParentFolder(PYTHON_WIN) _                    + vbCrLf + ", " + ParentFolder(ParentFolder(PYTHON_WIN))            End If        End If    End IfEnd SubFunction NDims(ByRef src As Variant, dims As Long, Optional transpose As Boolean = False)    XLPyLoadDLL    If 0 <> XLPyDLLNDims(src, dims, transpose, NDims) Then Err.Raise 1001, Description:=NDimsEnd FunctionFunction Py()    XLPyLoadDLL    If 0 <> XLPyDLLActivateAuto(Py, XLPyCommand, 1) Then Err.Raise 1000, Description:=PyEnd FunctionSub KillPy()    XLPyLoadDLL    Dim unused    If 0 <> XLPyDLLActivateAuto(unused, XLPyCommand, -1) Then Err.Raise 1000, Description:=unusedEnd SubSub ImportPythonUDFsBase(Optional addin As Boolean = False)    ' This is called from the Ribbon button    Dim tempPath As String, errorMsg As String    Dim wb As Workbook    If GetConfig("CONDA PATH") <> "" And CheckConda(GetConfig("CONDA PATH")) = False Then        Exit Sub    End If    If addin = True Then        Set wb = ThisWorkbook    Else        Set wb = ActiveWorkbook    End If    On Error GoTo ImportError        tempPath = Py.Str(Py.Call(Py.Module("xlwings"), "import_udfs", Py.Tuple(GetUdfModules(wb), wb)))    Exit SubImportError:    errorMsg = Err.Description & " " & Err.Number    ShowError "", errorMsgEnd SubSub ImportPythonUDFs()    ImportPythonUDFsBaseEnd SubSub ImportPythonUDFsToAddin()    ImportPythonUDFsBase addin:=TrueEnd SubSub ImportXlwingsUdfsModule(tf As String)    ' Fallback: This is called from Python as direct pywin32 calls were sometimes failing, see comments in the Python code    On Error Resume Next    ActiveWorkbook.VBProject.VBComponents.Remove ActiveWorkbook.VBProject.VBComponents("xlwings_udfs")    On Error GoTo 0    ActiveWorkbook.VBProject.VBComponents.Import tfEnd SubPrivate Sub GetDLLVersion()    ' Currently only for testing    Dim tag As String, arch As String    Dim ver As Double    XLPyDLLVersion tag, ver, arch    Debug.Print tag    Debug.Print ver    Debug.Print archEnd Sub
---------------------------------------------------

xlwings(xlwings.xlam) -> Modules -> RibbonXlwings

Option Explicit' Ribbon docs: https://msdn.microsoft.com/en-us/library/dd910855(v=office.12).aspx' Custom UI Editor: https://github.com/fernandreu/office-ribbonx-editorSub RunMain(control As IRibbonControl)    Dim wb As Workbook    Dim mymodule As String    Set wb = ActiveWorkbook        If ActiveWorkbook.Path = vbNullString Then        MsgBox "Please save this workbook (""" + wb.name + """) first."        Exit Sub    Else        mymodule = Left(wb.name, (InStrRev(wb.name, ".", -1, vbTextCompare) - 1))    End If        Application.StatusBar = "Running..."    RunPython "import " & mymodule & ";" & mymodule & ".main()"    Application.StatusBar = FalseEnd SubSub ImportFunctions(control As IRibbonControl)    #If Mac Then    #Else    Dim wb As Workbook    Set wb = ActiveWorkbook    If LCase$(Right$(wb.name, 5)) <> ".xlsm" And LCase$(Right$(wb.name, 5)) <> ".xlsb" And LCase$(Right$(wb.name, 5)) <> ".xlam" Then        MsgBox "Please save this workbook (""" + wb.name + """) as a macro-enabled workbook first."        Exit Sub    End If    KillPy    ImportPythonUDFs    Set wb = Nothing    #End IfEnd SubSub GetVisible(control As IRibbonControl, ByRef returnedVal)    #If Mac Then        returnedVal = False    #Else        returnedVal = True    #End IfEnd SubSub GetVersion(control As IRibbonControl, ByRef returnedVal)    returnedVal = "Version: " & XLWINGS_VERSIONEnd SubSub SetInterpreter(control As IRibbonControl, text As String)    Dim tf As Boolean    Dim interpreter As String    #If Mac Then        interpreter = "INTERPRETER_MAC"    #Else        interpreter = "INTERPRETER_WIN"    #End If    tf = SaveConfigToFile(GetConfigFilePath, interpreter, text)End SubSub GetInterpreter(control As IRibbonControl, ByRef returnedVal)    Dim setting As String, interpreter As String    #If Mac Then        interpreter = "INTERPRETER_MAC"    #Else        interpreter = "INTERPRETER_WIN"    #End If    If GetConfigFromFile(GetConfigFilePath(), interpreter, setting) Then        returnedVal = setting    Else        If GetConfigFromFile(GetConfigFilePath(), "INTERPRETER", setting) Then            ' Legacy            returnedVal = setting        Else            returnedVal = ""        End If    End IfEnd SubSub SetPythonpath(control As IRibbonControl, text As String)    Dim tf As Boolean    tf = SaveConfigToFile(GetConfigFilePath, "PYTHONPATH", text)End SubSub GetPythonpath(control As IRibbonControl, ByRef returnedVal)    Dim setting As String    If GetConfigFromFile(GetConfigFilePath, "PYTHONPATH", setting) Then        returnedVal = setting    Else        returnedVal = ""    End IfEnd SubSub SetCondaPath(control As IRibbonControl, text As String)    Dim tf As Boolean    tf = SaveConfigToFile(GetConfigFilePath, "CONDA PATH", text)End SubSub GetCondaPath(control As IRibbonControl, ByRef returnedVal)    Dim setting As String    If GetConfigFromFile(GetConfigFilePath, "CONDA PATH", setting) Then        returnedVal = setting    Else        returnedVal = ""    End IfEnd SubSub SetCondaEnv(control As IRibbonControl, text As String)    Dim tf As Boolean    tf = SaveConfigToFile(GetConfigFilePath, "CONDA ENV", text)End SubSub GetCondaEnv(control As IRibbonControl, ByRef returnedVal)    Dim setting As String    If GetConfigFromFile(GetConfigFilePath, "CONDA ENV", setting) Then        returnedVal = setting    Else        returnedVal = ""    End IfEnd SubSub SetUdfModules(control As IRibbonControl, text As String)    #If Mac Then    #Else        Dim tf As Boolean        tf = SaveConfigToFile(GetConfigFilePath, "UDF MODULES", text)    #End IfEnd SubSub GetUdfModules(control As IRibbonControl, ByRef returnedVal)    #If Mac Then    #Else        Dim setting As String        If GetConfigFromFile(GetConfigFilePath, "UDF MODULES", setting) Then            returnedVal = setting        Else            returnedVal = ""        End If    #End IfEnd SubSub ChangeUdfDebug(control As IRibbonControl, pressed As Boolean)    #If Mac Then    #Else    Dim tf As Boolean    tf = SaveConfigToFile(GetConfigFilePath, "DEBUG UDFS", CStr(pressed))    #End IfEnd SubSub GetPressedUdfDebug(control As IRibbonControl, ByRef pressed)    #If Mac Then    #Else    Dim setting As String    If GetConfigFromFile(GetConfigFilePath, "DEBUG UDFS", setting) Then        If setting = "True" Then            pressed = True        Else            pressed = False        End If    Else        pressed = False    End If    #End IfEnd SubSub ChangeUdfServer(control As IRibbonControl, pressed As Boolean)    #If Mac Then    #Else    Dim tf As Boolean    tf = SaveConfigToFile(GetConfigFilePath, "USE UDF SERVER", CStr(pressed))    #End IfEnd SubSub GetPressedUdfServer(control As IRibbonControl, ByRef pressed)    #If Mac Then    #Else    Dim setting As String    If GetConfigFromFile(GetConfigFilePath, "USE UDF SERVER", setting) Then        If setting = "True" Then            pressed = True        Else            pressed = False        End If    Else        pressed = False    End If    #End IfEnd SubSub ChangeShowConsole(control As IRibbonControl, pressed As Boolean)    #If Mac Then    #Else    Dim tf As Boolean    tf = SaveConfigToFile(GetConfigFilePath, "SHOW CONSOLE", CStr(pressed))    #End IfEnd SubSub GetPressedShowConsole(control As IRibbonControl, ByRef pressed)    #If Mac Then    #Else    Dim setting As String    If GetConfigFromFile(GetConfigFilePath, "SHOW CONSOLE", setting) Then        If setting = "True" Then            pressed = True        Else            pressed = False        End If    Else        pressed = False    End If    #End IfEnd SubSub RestartPython(control As IRibbonControl)    #If Mac Then    #Else    KillPy    Py.Exec ""    #End IfEnd Sub

---------------------------------------------------

xlwings(xlwings.xlam) -> Modules -> Utils

Option Explicit#Const App = "Microsoft Excel" 'Adjust when using outside of ExcelFunction IsFullName(sFile As String) As Boolean  ' if sFile includes path, it contains path separator "\" or "/"  IsFullName = InStr(sFile, "\") + InStr(sFile, "/") > 0End FunctionFunction FileExists(ByVal FileSpec As String) As Boolean    #If Mac Then        FileExists = FileOrFolderExistsOnMac(FileSpec)    #Else        FileExists = FileExistsOnWindows(FileSpec)    #End IfEnd FunctionFunction FileExistsOnWindows(ByVal FileSpec As String) As Boolean   ' by Karl Peterson MS MVP VB   Dim Attr As Long   ' Guard against bad FileSpec by ignoring errors   ' retrieving its attributes.   On Error Resume Next   Attr = GetAttr(FileSpec)   If Err.Number = 0 Then      ' No error, so something was found.      ' If Directory attribute set, then not a file.      FileExistsOnWindows = Not ((Attr And vbDirectory) = vbDirectory)   End IfEnd FunctionFunction FileOrFolderExistsOnMac(FileOrFolderstr As String) As Boolean'Ron de Bruin : 26-June-2015'Function to test whether a file or folder exist on a Mac in office 2011 and up'Uses AppleScript to avoid the problem with long names in Office 2011,'limit is max 32 characters including the extension in 2011.    Dim ScriptToCheckFileFolder As String    Dim TestStr As String        #If Mac Then    If Val(Application.VERSION) < 15 Then        ScriptToCheckFileFolder = "tell application " & Chr(34) & "System Events" & Chr(34) & _         "to return exists disk item (" & Chr(34) & FileOrFolderstr & Chr(34) & " as string)"        FileOrFolderExistsOnMac = MacScript(ScriptToCheckFileFolder)    Else        On Error Resume Next        TestStr = Dir(FileOrFolderstr, vbDirectory)        On Error GoTo 0        If Not TestStr = vbNullString Then FileOrFolderExistsOnMac = True    End If    #End IfEnd FunctionFunction ParentFolder(ByVal Folder)  #If Mac Then      ParentFolder = Left$(Folder, InStrRev(Folder, "/") - 1)  #Else      ParentFolder = Left$(Folder, InStrRev(Folder, "\") - 1)  #End IfEnd FunctionFunction GetDirectory(Path)    #If Mac Then    GetDirectory = Left(Path, InStrRev(Path, "/"))    #Else    GetDirectory = Left(Path, InStrRev(Path, "\"))    #End IfEnd FunctionFunction KillFileOnMac(Filestr As String)    'Ron de Bruin    '30-July-2012    'Delete files from a Mac.    'Uses AppleScript to avoid the problem with long file names (on 2011 only)    Dim ScriptToKillFile As String        #If Mac Then    ScriptToKillFile = "tell application " & Chr(34) & "Finder" & Chr(34) & Chr(13)    ScriptToKillFile = ScriptToKillFile & "do shell script ""rm "" & quoted form of posix path of " & Chr(34) & Filestr & Chr(34) & Chr(13)    ScriptToKillFile = ScriptToKillFile & "end tell"    On Error Resume Next        MacScript (ScriptToKillFile)    On Error GoTo 0    #End IfEnd FunctionFunction ToMacPath(PosixPath As String) As String    ' This function transforms a Posix Path into a MacOS Path    ' E.g. "/Users/<User>" --> "MacintoshHD:Users:<User>"    #If Mac Then    ToMacPath = MacScript("set mac_path to POSIX file " & Chr(34) & PosixPath & Chr(34) & " as string")    #End IfEnd FunctionFunction GetMacDir(name As String, Normalize As Boolean) As String    #If Mac Then        Select Case name            Case "$HOME"                name = "home folder"            Case "$APPLICATIONS"                name = "applications folder"            Case "$DOCUMENTS"                name = "documents folder"            Case "$DOWNLOADS"                name = "downloads folder"            Case "$DESKTOP"                name = "desktop folder"            Case "$TMPDIR"                name = "temporary items"        End Select        GetMacDir = MacScript("return POSIX path of (path to " & name & ") as string")        If Normalize = True Then            'Normalize Excel sandbox location            GetMacDir = Replace(GetMacDir, "/Library/Containers/com.microsoft.Excel/Data", "")        End If    #Else    #End IfEnd FunctionFunction ToPosixPath(ByVal MacPath As String) As String    'This function accepts relative paths with backward and forward slashes: ActiveWorkbook & "\test"    ' E.g. "MacintoshHD:Users:<User>" --> "/Users/<User>"    Dim s As String    Dim LeadingSlash As Boolean        #If Mac Then    If MacPath = "" Then        ToPosixPath = ""    Else        ToPosixPath = Replace(MacPath, "\", "/")        ToPosixPath = MacScript("return POSIX path of (" & Chr(34) & MacPath & Chr(34) & ") as string")    End If    #End IfEnd FunctionSub ShowError(FileName As String, Optional message As String = "")    ' Shows a MsgBox with the content of a text file    Dim Content As String    Dim objShell    Dim ErrorSheet As Worksheet    Const OK_BUTTON_ERROR = 16    Const AUTO_DISMISS = 0        If message = "" Then        Content = ReadFile(FileName)    Else        Content = message    End If        If GetConfig("SHOW_ERROR_POPUPS", "True") = "False" Then        If SheetExists(ActiveWorkbook, "Error") = False Then            Set ErrorSheet = ActiveWorkbook.Sheets.Add()            ErrorSheet.name = "Error"        Else            Set ErrorSheet = ActiveWorkbook.Sheets("Error")        End If        ErrorSheet.Range("A1").Value = Content    Else        #If Mac Then            MsgBox Content, vbCritical, "Error"        #Else            Content = Content & vbCrLf            Content = Content & "Press Ctrl+C to copy this message to the clipboard."                Set objShell = CreateObject("Wscript.Shell")            objShell.Popup Content, AUTO_DISMISS, "Error", OK_BUTTON_ERROR        #End If    End IfEnd SubFunction ExpandEnvironmentStrings(ByVal s As String)    ' Expand environment variables    Dim EnvString As String    Dim PathParts As Variant    Dim i As Integer    #If Mac Then        If Left(s, 1) = "$" Then            PathParts = Split(s, "/")            EnvString = PathParts(0)            ExpandEnvironmentStrings = GetMacDir(EnvString, True)            For i = 1 To UBound(PathParts)                If Right$(ExpandEnvironmentStrings, 1) = "/" Then                    ExpandEnvironmentStrings = ExpandEnvironmentStrings & PathParts(i)                Else                    ExpandEnvironmentStrings = ExpandEnvironmentStrings & "/" & PathParts(i)                End If            Next i        Else            ExpandEnvironmentStrings = s        End If    #Else        Dim objShell As Object        Set objShell = CreateObject("WScript.Shell")        ExpandEnvironmentStrings = objShell.ExpandEnvironmentStrings(s)        Set objShell = Nothing    #End IfEnd FunctionFunction ReadFile(ByVal FileName As String)    ' Read a text file    Dim Content As String    Dim Token As String    Dim FileNum As Integer    Dim objShell As Object    Dim LineBreak As Variant    #If Mac Then        FileName = ToMacPath(FileName)        LineBreak = vbLf    #Else        FileName = ExpandEnvironmentStrings(FileName)        LineBreak = vbCrLf    #End If    FileNum = FreeFile    Content = ""    ' Read Text File    Open FileName For Input As #FileNum        Do While Not EOF(FileNum)            Line Input #FileNum, Token            Content = Content & Token & LineBreak        Loop    Close #FileNum    ReadFile = ContentEnd Function#If App = "Microsoft Excel" ThenFunction SheetExists(wb As Workbook, sheetName As String) As Boolean    Dim sht As Worksheet    On Error Resume Next        Set sht = wb.Sheets(sheetName)    On Error GoTo 0    SheetExists = Not sht Is NothingEnd Function#End IfFunction GetBaseName(wb As String) As String    Dim extension As String    extension = LCase$(Right$(wb, 4))    If extension = ".xls" Or extension = ".xla" Or extension = ".xlt" Then        GetBaseName = Left$(wb, Len(wb) - 4)    Else        GetBaseName = Left$(wb, Len(wb) - 5)    End IfEnd FunctionFunction has_dynamic_array() As Boolean    has_dynamic_array = False    On Error GoTo ErrHandler        Application.WorksheetFunction.Unique ("dummy")        has_dynamic_array = True    Exit FunctionErrHandler:    has_dynamic_array = FalseEnd FunctionPublic Function CreateGUID() As String    Randomize Timer() + Application.Hwnd    ' https://stackoverflow.com/a/46474125/918626    Do While Len(CreateGUID) < 32        If Len(CreateGUID) = 16 Then            '17th character holds version information            CreateGUID = CreateGUID & Hex$(8 + CInt(Rnd * 3))        End If        CreateGUID = CreateGUID & Hex$(CInt(Rnd * 15))    Loop    CreateGUID = Mid(CreateGUID, 1, 8) & "-" & Mid(CreateGUID, 9, 4) & "-" & Mid(CreateGUID, 13, 4) & "-" & Mid(CreateGUID, 17, 4) & "-" & Mid(CreateGUID, 21, 12)End FunctionFunction CheckConda(CondaPath As String) As Boolean    ' Check if the conda executable exists.    ' If it doesn't, conda is too old and the Interpreter setting has to be used instead of Conda settings    Dim condaExecutable As String    Dim condaExists As Boolean    #If Mac Then        condaExecutable = CondaPath & "\condabin\conda"    #Else        condaExecutable = CondaPath & "\condabin\conda.bat"    #End If    ' Replace space escape character ^ to check if path exists    condaExists = FileExists(Replace(condaExecutable, "^", ""))    If condaExists = False And CondaPath <> "" Then        MsgBox "Your Conda version seems to be too old for the Conda settings. Use the Interpreter setting instead."    End If    CheckConda = condaExistsEnd Function#If App = "Microsoft Excel" ThenFunction GetFullName(wb As Workbook) As String    ' The only case where this is still used is for directory-based config files, otherwise this is now handled in Python    ' Unlike the Python version, this doesn't work for SharePoint and will just ignore a directory-based config file silently    Dim total_found, i_parsing, i_env_var, slash_number As Integer    Dim found_path, one_drive_path, full_path_name, this_found_path As String    ' In the majority of cases, ThisWorkbook.FullName will provide the path of the    ' Excel workbook correctly. Unfortunately, when the user is using OneDrive    ' this doesn't work. This function will attempt to find the LOCAL path.    ' This uses code from Daniel Guetta and    ' https://stackoverflow.com/questions/33734706/excels-fullname-property-with-onedrive        If InStr(wb.FullName, "://") = 0 Or wb.Path = "" Then        GetFullName = wb.FullName        Exit Function    End If            ' According to the link above, there are three possible environment variables    ' the user's OneDrive folder could be located in    '      "OneDriveCommercial", "OneDriveConsumer", "OneDrive"    '    ' Furthermore, there are two possible formats for OneDrive URLs    '    1. "https://companyName-my.sharepoint.com/personal/userName_domain_com/Documents" & file.FullName    '    2. "https://d.docs.live.net/d7bbaa#######1/" & file.FullName    ' In the first case, we can find the true path by just looking for everything after /Documents. In the    ' second, we need to look for the fourth slash in the URL    '    ' The code below will try every combination of the three environment variables above, and    ' each of the two methods of parsing the URL. The file is found in *exactly* one of those    ' locations, then we're good to go.    '    ' Note that this still leaves a gap - if this file (file A) is in a location that is NOT covered by the    ' eventualities above AND a file of the exact same name (file B) exists in one of the locations that is    ' covered above, then this function will identify File B's location as the location of this workbook,    ' which would be wrong    total_found = 0        For i_parsing = 1 To 2        If i_parsing = 1 Then            ' Parse using method 1 above; find /Documents and take everything after, INCLUDING the            ' leading slash            If InStr(1, wb.FullName, "/Documents") Then                full_path_name = Mid(wb.FullName, InStr(1, wb.FullName, "/Documents") + Len("/Documents"))            Else                full_path_name = ""            End If        Else            ' Parse using method 2; find everything after the fourth slash, including that fourth            ' slash            Dim i_pos As Integer                        ' Start at the last slash in https://            i_pos = 8            For slash_number = 1 To 2                i_pos = InStr(i_pos + 1, wb.FullName, "/")            Next slash_number                        full_path_name = Mid(wb.FullName, i_pos)        End If                ' Replace forward slahes with backslashes on Windows        full_path_name = Replace(full_path_name, "/", Application.pathSeparator)                        If full_path_name <> "" Then            #If Not Mac Then            For i_env_var = 1 To 3                    one_drive_path = Environ(Choose(i_env_var, "OneDriveCommercial", "OneDriveConsumer", "OneDrive"))                                    If (one_drive_path <> "") And FileExists(one_drive_path & full_path_name) Then                        this_found_path = one_drive_path & full_path_name                                                If this_found_path <> found_path Then                            total_found = total_found + 1                            found_path = this_found_path                        End If                    End If            Next i_env_var            #End If        End If    Next i_parsing            If total_found = 1 Then        GetFullName = found_path        Exit Function    End IfEnd Function#End If---------------------------------------------------

xlwings(xlwings.xlam) -> Class Modules -> Dictionary

''' Dictionary v1.4.1' (c) Tim Hall - https://github.com/timhall/VBA-Dictionary'' Drop-in replacement for Scripting.Dictionary on Mac'' @author: tim.hall.engr@gmail.com' @license: MIT (http://www.opensource.org/licenses/mit-license.php'' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 'Option Explicit' --------------------------------------------- '' Constants and Private Variables' --------------------------------------------- '#Const UseScriptingDictionaryIfAvailable = True#If Mac Or Not UseScriptingDictionaryIfAvailable Then' dict_KeyValue 0: FormattedKey, 1: OriginalKey, 2: ValuePrivate dict_pKeyValues As CollectionPrivate dict_pKeys() As VariantPrivate dict_pItems() As VariantPrivate dict_pObjectKeys As CollectionPrivate dict_pCompareMode As CompareMethod#ElsePrivate dict_pDictionary As Object#End If' --------------------------------------------- '' Types' --------------------------------------------- 'Public Enum CompareMethod    BinaryCompare = VBA.vbBinaryCompare    TextCompare = VBA.vbTextCompare    DatabaseCompare = VBA.vbDatabaseCompareEnd Enum' --------------------------------------------- '' Properties' --------------------------------------------- 'Public Property Get CompareMode() As CompareMethod#If Mac Or Not UseScriptingDictionaryIfAvailable Then    CompareMode = dict_pCompareMode#Else    CompareMode = dict_pDictionary.CompareMode#End IfEnd PropertyPublic Property Let CompareMode(Value As CompareMethod)#If Mac Or Not UseScriptingDictionaryIfAvailable Then    If Me.Count > 0 Then        ' Can't change CompareMode for Dictionary that contains data        ' http://msdn.microsoft.com/en-us/library/office/gg278481(v=office.15).aspx        Err.Raise 5 ' Invalid procedure call or argument    End If    dict_pCompareMode = Value#Else    dict_pDictionary.CompareMode = Value#End IfEnd PropertyPublic Property Get Count() As Long#If Mac Or Not UseScriptingDictionaryIfAvailable Then    Count = dict_pKeyValues.Count#Else    Count = dict_pDictionary.Count#End IfEnd PropertyPublic Property Get Item(Key As Variant) As Variant#If Mac Or Not UseScriptingDictionaryIfAvailable Then    Dim dict_KeyValue As Variant    dict_KeyValue = dict_GetKeyValue(Key)    If Not IsEmpty(dict_KeyValue) Then        If VBA.IsObject(dict_KeyValue(2)) Then            Set Item = dict_KeyValue(2)        Else            Item = dict_KeyValue(2)        End If    Else        ' Not found -> Returns Empty    End If#Else    If VBA.IsObject(dict_pDictionary.Item(Key)) Then        Set Item = dict_pDictionary.Item(Key)    Else        Item = dict_pDictionary.Item(Key)    End If#End IfEnd PropertyPublic Property Let Item(Key As Variant, Value As Variant)#If Mac Or Not UseScriptingDictionaryIfAvailable Then    If Me.Exists(Key) Then        dict_ReplaceKeyValue dict_GetKeyValue(Key), Key, Value    Else        dict_AddKeyValue Key, Value    End If#Else    dict_pDictionary.Item(Key) = Value#End IfEnd PropertyPublic Property Set Item(Key As Variant, Value As Variant)#If Mac Or Not UseScriptingDictionaryIfAvailable Then    If Me.Exists(Key) Then        dict_ReplaceKeyValue dict_GetKeyValue(Key), Key, Value    Else        dict_AddKeyValue Key, Value    End If#Else    Set dict_pDictionary.Item(Key) = Value#End IfEnd PropertyPublic Property Let Key(Previous As Variant, Updated As Variant)#If Mac Or Not UseScriptingDictionaryIfAvailable Then    Dim dict_KeyValue As Variant    dict_KeyValue = dict_GetKeyValue(Previous)    If Not VBA.IsEmpty(dict_KeyValue) Then        dict_ReplaceKeyValue dict_KeyValue, Updated, dict_KeyValue(2)    End If#Else    dict_pDictionary.Key(Previous) = Updated#End IfEnd Property' ============================================= '' Public Methods' ============================================= '''' Add an item with the given key'' @param {Variant} Key' @param {Variant} Item' --------------------------------------------- 'Public Sub Add(Key As Variant, Item As Variant)#If Mac Or Not UseScriptingDictionaryIfAvailable Then    If Not Me.Exists(Key) Then        dict_AddKeyValue Key, Item    Else        ' This key is already associated with an element of this collection        Err.Raise 457    End If#Else    dict_pDictionary.Add Key, Item#End IfEnd Sub''' Check if an item exists for the given key'' @param {Variant} Key' @return {Boolean}' --------------------------------------------- 'Public Function Exists(Key As Variant) As Boolean#If Mac Or Not UseScriptingDictionaryIfAvailable Then    Exists = Not IsEmpty(dict_GetKeyValue(Key))#Else    Exists = dict_pDictionary.Exists(Key)#End IfEnd Function''' Get an array of all items'' @return {Variant}' --------------------------------------------- 'Public Function Items() As Variant#If Mac Or Not UseScriptingDictionaryIfAvailable Then    If Me.Count > 0 Then        Items = dict_pItems    Else        ' Split("") creates initialized empty array that matches Dictionary Keys and Items        Items = VBA.Split("")    End If#Else    Items = dict_pDictionary.Items#End IfEnd Function''' Get an array of all keys'' @return {Variant}' --------------------------------------------- 'Public Function Keys() As Variant#If Mac Or Not UseScriptingDictionaryIfAvailable Then    If Me.Count > 0 Then        Keys = dict_pKeys    Else        ' Split("") creates initialized empty array that matches Dictionary Keys and Items        Keys = VBA.Split("")    End If#Else    Keys = dict_pDictionary.Keys#End IfEnd Function''' Remove an item for the given key'' @param {Variant} Key' --------------------------------------------- 'Public Sub Remove(Key As Variant)#If Mac Or Not UseScriptingDictionaryIfAvailable Then    Dim dict_KeyValue As Variant    dict_KeyValue = dict_GetKeyValue(Key)    If Not VBA.IsEmpty(dict_KeyValue) Then        dict_RemoveKeyValue dict_KeyValue    Else        ' Application-defined or object-defined error        Err.Raise 32811    End If#Else    dict_pDictionary.Remove Key#End IfEnd Sub''' Remove all items' --------------------------------------------- 'Public Sub RemoveAll()#If Mac Or Not UseScriptingDictionaryIfAvailable Then    Set dict_pKeyValues = New Collection    Erase dict_pKeys    Erase dict_pItems#Else    dict_pDictionary.RemoveAll#End IfEnd Sub' ============================================= '' Private Functions' ============================================= '#If Mac Or Not UseScriptingDictionaryIfAvailable ThenPrivate Function dict_GetKeyValue(dict_Key As Variant) As Variant    On Error Resume Next    dict_GetKeyValue = dict_pKeyValues(dict_GetFormattedKey(dict_Key))    Err.ClearEnd FunctionPrivate Sub dict_AddKeyValue(dict_Key As Variant, dict_Value As Variant, Optional dict_Index As Long = -1)    If Me.Count = 0 Then        ReDim dict_pKeys(0 To 0)        ReDim dict_pItems(0 To 0)    Else        ReDim Preserve dict_pKeys(0 To UBound(dict_pKeys) + 1)        ReDim Preserve dict_pItems(0 To UBound(dict_pItems) + 1)    End If    Dim dict_FormattedKey As String    dict_FormattedKey = dict_GetFormattedKey(dict_Key)    If dict_Index >= 0 And dict_Index < dict_pKeyValues.Count Then        ' Shift keys/items after + including index into empty last slot        Dim dict_i As Long        For dict_i = UBound(dict_pKeys) To dict_Index + 1 Step -1            dict_pKeys(dict_i) = dict_pKeys(dict_i - 1)            If VBA.IsObject(dict_pItems(dict_i - 1)) Then                Set dict_pItems(dict_i) = dict_pItems(dict_i - 1)            Else                dict_pItems(dict_i) = dict_pItems(dict_i - 1)            End If        Next dict_i        ' Add key/item at index        dict_pKeys(dict_Index) = dict_Key        If VBA.IsObject(dict_Value) Then            Set dict_pItems(dict_Index) = dict_Value        Else            dict_pItems(dict_Index) = dict_Value        End If        ' Add key-value at proper index        dict_pKeyValues.Add Array(dict_FormattedKey, dict_Key, dict_Value), dict_FormattedKey, Before:=dict_Index + 1    Else        ' Add key-value as last item        If VBA.IsObject(dict_Key) Then            Set dict_pKeys(UBound(dict_pKeys)) = dict_Key        Else            dict_pKeys(UBound(dict_pKeys)) = dict_Key        End If        If VBA.IsObject(dict_Value) Then            Set dict_pItems(UBound(dict_pItems)) = dict_Value        Else            dict_pItems(UBound(dict_pItems)) = dict_Value        End If        dict_pKeyValues.Add Array(dict_FormattedKey, dict_Key, dict_Value), dict_FormattedKey    End IfEnd SubPrivate Sub dict_ReplaceKeyValue(dict_KeyValue As Variant, dict_Key As Variant, dict_Value As Variant)    Dim dict_Index As Long    Dim dict_i As Integer    dict_Index = dict_GetKeyIndex(dict_KeyValue(1))    ' Remove existing dict_Value    dict_RemoveKeyValue dict_KeyValue, dict_Index    ' Add new dict_Key dict_Value back    dict_AddKeyValue dict_Key, dict_Value, dict_IndexEnd SubPrivate Sub dict_RemoveKeyValue(dict_KeyValue As Variant, Optional ByVal dict_Index As Long = -1)    Dim dict_i As Long    If dict_Index = -1 Then        dict_Index = dict_GetKeyIndex(dict_KeyValue(1))    End If    If dict_Index >= 0 And dict_Index <= UBound(dict_pKeys) Then        ' Shift keys/items after index down        For dict_i = dict_Index To UBound(dict_pKeys) - 1            dict_pKeys(dict_i) = dict_pKeys(dict_i + 1)            If VBA.IsObject(dict_pItems(dict_i + 1)) Then                Set dict_pItems(dict_i) = dict_pItems(dict_i + 1)            Else                dict_pItems(dict_i) = dict_pItems(dict_i + 1)            End If        Next dict_i        ' Resize keys/items to remove empty slot        If UBound(dict_pKeys) = 0 Then            Erase dict_pKeys            Erase dict_pItems        Else            ReDim Preserve dict_pKeys(0 To UBound(dict_pKeys) - 1)            ReDim Preserve dict_pItems(0 To UBound(dict_pItems) - 1)        End If    End If    dict_pKeyValues.Remove dict_KeyValue(0)    dict_RemoveObjectKey dict_KeyValue(1)End SubPrivate Function dict_GetFormattedKey(dict_Key As Variant) As String    If VBA.IsObject(dict_Key) Then        dict_GetFormattedKey = dict_GetObjectKey(dict_Key)    ElseIf VarType(dict_Key) = VBA.vbBoolean Then        dict_GetFormattedKey = IIf(dict_Key, "-1__-1", "0__0")    ElseIf VarType(dict_Key) = VBA.vbString Then        dict_GetFormattedKey = dict_Key        If Me.CompareMode = CompareMethod.BinaryCompare Then            ' Collection does not have method of setting key comparison            ' So case-sensitive keys aren't supported by default            ' -> Approach: Append lowercase characters to original key            '    AbC -> AbC___b_, abc -> abc__abc, ABC -> ABC_____            Dim dict_Lowercase As String            dict_Lowercase = ""            Dim dict_i As Integer            Dim dict_Char As String            Dim dict_Ascii As Integer            For dict_i = 1 To VBA.Len(dict_GetFormattedKey)                dict_Char = VBA.Mid$(dict_GetFormattedKey, dict_i, 1)                dict_Ascii = VBA.Asc(dict_Char)                If dict_Ascii >= 97 And dict_Ascii <= 122 Then                    dict_Lowercase = dict_Lowercase & dict_Char                Else                    dict_Lowercase = dict_Lowercase & "_"                End If            Next dict_i            If dict_Lowercase <> "" Then                dict_GetFormattedKey = dict_GetFormattedKey & "__" & dict_Lowercase            End If        End If    Else        ' For numbers, add duplicate to distinguish from strings        ' ->  123  -> "123__123"        '    "123" -> "123"        dict_GetFormattedKey = VBA.CStr(dict_Key) & "__" & CStr(dict_Key)    End IfEnd FunctionPrivate Function dict_GetObjectKey(dict_ObjKey As Variant) As String    Dim dict_i As Integer    For dict_i = 1 To dict_pObjectKeys.Count        If dict_pObjectKeys.Item(dict_i) Is dict_ObjKey Then            dict_GetObjectKey = "__object__" & dict_i            Exit Function        End If    Next dict_i    dict_pObjectKeys.Add dict_ObjKey    dict_GetObjectKey = "__object__" & dict_pObjectKeys.CountEnd FunctionPrivate Sub dict_RemoveObjectKey(dict_ObjKey As Variant)    Dim dict_i As Integer    For dict_i = 1 To dict_pObjectKeys.Count        If dict_pObjectKeys.Item(dict_i) Is dict_ObjKey Then            dict_pObjectKeys.Remove dict_i            Exit Sub        End If    Next dict_iEnd SubPrivate Function dict_GetKeyIndex(dict_Key As Variant) As Long    Dim dict_i As Long    For dict_i = 0 To UBound(dict_pKeys)        If VBA.IsObject(dict_pKeys(dict_i)) And VBA.IsObject(dict_Key) Then            If dict_pKeys(dict_i) Is dict_Key Then                dict_GetKeyIndex = dict_i                Exit For            End If        ElseIf VBA.IsObject(dict_pKeys(dict_i)) Or VBA.IsObject(dict_Key) Then            ' Both need to be objects to check equality, skip        ElseIf dict_pKeys(dict_i) = dict_Key Then            dict_GetKeyIndex = dict_i            Exit For        End If    Next dict_iEnd Function#End IfPrivate Sub Class_Initialize()#If Mac Or Not UseScriptingDictionaryIfAvailable Then    Set dict_pKeyValues = New Collection    Erase dict_pKeys    Erase dict_pItems    Set dict_pObjectKeys = New Collection#Else    Set dict_pDictionary = CreateObject("Scripting.Dictionary")#End IfEnd SubPrivate Sub Class_Terminate()#If Mac Or Not UseScriptingDictionaryIfAvailable Then    Set dict_pKeyValues = Nothing    Set dict_pObjectKeys = Nothing#Else    Set dict_pDictionary = Nothing#End IfEnd Sub

